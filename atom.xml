<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruan❥(^_-) Blog</title>
  
  
  <link href="https://ruan0423.github.io/atom.xml" rel="self"/>
  
  <link href="https://ruan0423.github.io/"/>
  <updated>2023-10-29T14:22:46.514Z</updated>
  <id>https://ruan0423.github.io/</id>
  
  <author>
    <name>Traveler</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python之re库，正则表达</title>
    <link href="https://ruan0423.github.io/2023/10/29/python%E4%B9%8Bre%E5%BA%93%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/"/>
    <id>https://ruan0423.github.io/2023/10/29/python%E4%B9%8Bre%E5%BA%93%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/</id>
    <published>2023-10-29T09:02:41.000Z</published>
    <updated>2023-10-29T14:22:46.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>为什么要学re库呢？这里主要学他的正则表达，在编写安全脚本的时候肯定要遇到一些不规则的匹配规则，当然编写爬虫也少不了正则匹配去找到一些具有特殊特征的字符串。因此这是十分必要的，然而。re库使 Python 语言拥有全部的正则表达式功能。我会先介绍一些常见的函数的功能并且举例。后再举例说明。一些常见的情况。当然除了掌握函数的功能，这只是基础，重点是自己会构造pattern。</p><p>这里介绍的匹配通俗来讲就是在一段字符串里面找某段字符串（pattern），在re库里面就有re.match()和re.search()等一些函数来找。</p><p>一定要会使用编译函数comlie(),find_all(),还有会正则表达格式。</p><h1 id="二、re-match"><a href="#二、re-match" class="headerlink" title="二、re.match()"></a>二、re.match()</h1><p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 none。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">规则是</span><br><span class="line">re.match(pattern,string,flag)</span><br></pre></td></tr></table></figure><p>举例说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">print(re.match(&#x27;www&#x27;,&#x27;www.baidu.com&#x27;))</span><br><span class="line">print(re.match(&#x27;www&#x27;,&#x27;www.baidu.com&#x27;).span())</span><br><span class="line">print(re.match(&#x27;www&#x27;,&#x27;ewwww&#x27;))</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">&lt;re.Match object; span=(0, 3), match=&#x27;www&#x27;&gt; #匹配成功返回一个对象</span><br><span class="line">（0,3）#只要起始位置到结束</span><br><span class="line">None#起始位置不匹配。返回空</span><br></pre></td></tr></table></figure><p>这里就要提到另外一个知识点，我们知道，re.match返回的是一个obj，其中里面包含了span也就是位置，那我要返回匹配到的字符呢？为什么要返回匹配到的字符呢？因为这里的pattern到后面我们是自己设置的一些模式化的字符，比如我们要在一个js文件里面找出url，那么我们就要编写pattern模式，然后返回这个匹配到的模式字符。</p><p>所有这里引出来group()</p><p><strong>group()</strong></p><p>当使用正则表达式匹配时，通常会定义一个模式，该模式中包含一个或多个用括号括起来的子表达式，这些子表达式被称为”捕获组”。这些捕获组用于从匹配的文本中提取特定部分。例如，考虑以下示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">text = &quot;My phone number is 123-456-7890.&quot;</span><br><span class="line"></span><br><span class="line"># 匹配电话号码的模式，使用捕获组提取区号、中间号和最后四位数字</span><br><span class="line">pattern = r&#x27;(\d&#123;3&#125;)-(\d&#123;3&#125;)-(\d&#123;4&#125;)&#x27;</span><br><span class="line"></span><br><span class="line">match = re.search(pattern, text)</span><br><span class="line"></span><br><span class="line">if match:</span><br><span class="line">    full_match = match.group(0)  # 整个匹配</span><br><span class="line">    area_code = match.group(1)  # 第一个捕获组</span><br><span class="line">    middle_digits = match.group(2)  # 第二个捕获组</span><br><span class="line">    last_digits = match.group(3)  # 第三个捕获组</span><br><span class="line"></span><br><span class="line">    print(&quot;Full Match: &quot;, full_match)</span><br><span class="line">    print(&quot;Area Code: &quot;, area_code)</span><br><span class="line">    print(&quot;Middle Digits: &quot;, middle_digits)</span><br><span class="line">    print(&quot;Last Digits: &quot;, last_digits)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;No match.&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#结果</span><br><span class="line">Full Match:  123-456-7890</span><br><span class="line">Area Code:  123</span><br><span class="line">Middle Digits:  456</span><br><span class="line">Last Digits:  7890</span><br></pre></td></tr></table></figure><p>通俗解释就是：在<code>pattern = r&#39;(\d&#123;3&#125;)-(\d&#123;3&#125;)-(\d&#123;4&#125;)&#39;</code>模式中，有三个捕获组，当匹配到的时候就可以使用group（）返回整个匹配到的内容。使用group（1）就可以返回第一个捕获组。</p><p>如果要不区分大小写，就把flag设置为 re.M|re.I</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, text，re.M|re.I)</span><br></pre></td></tr></table></figure><h1 id="三、re-search"><a href="#三、re-search" class="headerlink" title="三、re.search()"></a>三、re.search()</h1><p>OK！到这里基本上已经了解到什么是匹配什么是模式，怎么返回匹配到的内容或者位置。现在引入另外一个常见的就是search</p><p>通常我们使用的都是这个去匹配而不是使用match；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">使用规则</span><br><span class="line">re.search(pattern,string,flag)</span><br><span class="line">与match的区别在于，search是从整个string中查找到pattern，然后返回obj,否则返回none。而match是只从开始找，如果一开始就不匹配那就返回none</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">pattern = &#x27;ww&#x27;</span><br><span class="line">string = &#x27;aww&#x27;</span><br><span class="line">string2 = &#x27;wwsdgsdww&#x27;</span><br><span class="line">match = re.search(pattern,string)</span><br><span class="line">match2 = re.search(pattern,string2)</span><br><span class="line">print(match)</span><br><span class="line">print(match2)</span><br><span class="line">print(match.group())</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line"></span><br><span class="line">&lt;re.Match object; span=(1, 3), match=&#x27;ww&#x27;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt;</span><br><span class="line">ww</span><br></pre></td></tr></table></figure><h1 id="四、替换函数re-sub（）"><a href="#四、替换函数re-sub（）" class="headerlink" title="四、替换函数re.sub（）"></a>四、替换函数re.sub（）</h1> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count=0, flags=0)</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">- pattern : 正则中的模式字符串。</span><br><span class="line">- repl : 替换的字符串，也可为一个函数。</span><br><span class="line">- string : 要被查找替换的原始字符串。</span><br><span class="line">- count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</span><br></pre></td></tr></table></figure><p>  举例：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">pattern = &#x27;ww&#x27;</span><br><span class="line">string2 = &#x27;wwsdgsdww&#x27;</span><br><span class="line">replace = re.sub(pattern,&quot;okok&quot;,string2)</span><br><span class="line">print(replace)</span><br><span class="line"></span><br><span class="line">#结果</span><br><span class="line">okoksdgsdokok</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="五、编译函数compile"><a href="#五、编译函数compile" class="headerlink" title="五、编译函数compile()"></a>五、编译函数compile()</h1><p>主要作用就是编译，什么意思？就是将pattern进行编译，在不编译pattern之前，我们是直接把pattern放进函数里面的，那样他会自己编译，但是当我们编译了之后就不用直接调用了。</p><p>  举例：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  import re</span><br><span class="line">  </span><br><span class="line">  pattern = &#x27;ww&#x27;</span><br><span class="line">  string2 = &#x27;wwsdgsdww&#x27;</span><br><span class="line">  replace = re.search(pattern,string2)</span><br><span class="line">  print(replace)</span><br><span class="line">  #使用编译</span><br><span class="line">  pattern = re.compile(pattern)</span><br><span class="line">  replace = pattern.search(string2)</span><br><span class="line">  print(replace)</span><br><span class="line">  </span><br><span class="line">  #输出</span><br><span class="line">  </span><br><span class="line">  &lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h1 id="六、查找函数find-all-，finditer"><a href="#六、查找函数find-all-，finditer" class="headerlink" title="六、查找函数find_all()，finditer()"></a>六、查找函数find_all()，finditer()</h1><p>与search的区别在于它找到的是多个，返回的是一个列表。</p><p>规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findall(string[, pos[, endpos]])</span><br><span class="line">比如：</span><br><span class="line">findall(string,0,10)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">pattern = &#x27;ww&#x27;</span><br><span class="line">string2 = &#x27;wwsdgsdww&#x27;</span><br><span class="line">pattern = re.compile(pattern)</span><br><span class="line">result = pattern.findall(string2)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">[&#x27;ww&#x27;, &#x27;ww&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>finditer和find_all一样。只不过finditer返回的是迭代，而不是列表。需要使用for循环print出来。</p><h1 id="七、正则表达式"><a href="#七、正则表达式" class="headerlink" title="七、正则表达式"></a>七、正则表达式</h1><p>这里很重要，但是知识点又很多，所以看懂就行，建议当要设置匹配某个字符的特征表达式的时候，集合chatgpt来写。</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配字符串的开头</td></tr><tr><td align="left">$</td><td align="left">匹配字符串的末尾。</td></tr><tr><td align="left">.</td><td align="left">匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td></tr><tr><td align="left">[…]</td><td align="left">用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td></tr><tr><td align="left">[^…]</td><td align="left">不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td></tr><tr><td align="left">re*</td><td align="left">匹配0个或多个的表达式。</td></tr><tr><td align="left">re+</td><td align="left">匹配1个或多个的表达式。</td></tr><tr><td align="left">re?</td><td align="left">匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td align="left">re{ n}</td><td align="left">精确匹配 n 个前面表达式。例如， <strong>o{2}</strong> 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">re{ n,}</td><td align="left">匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。</td></tr><tr><td align="left">re{ n, m}</td><td align="left">匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td></tr><tr><td align="left">a| b</td><td align="left">匹配a或b</td></tr><tr><td align="left">(re)</td><td align="left">对正则表达式分组并记住匹配的文本</td></tr><tr><td align="left">(?imx)</td><td align="left">正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td></tr><tr><td align="left">(?-imx)</td><td align="left">正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td></tr><tr><td align="left">(?: re)</td><td align="left">类似 (…), 但是不表示一个组</td></tr><tr><td align="left">(?imx: re)</td><td align="left">在括号中使用i, m, 或 x 可选标志</td></tr><tr><td align="left">(?-imx: re)</td><td align="left">在括号中不使用i, m, 或 x 可选标志</td></tr><tr><td align="left">(?#…)</td><td align="left">注释.</td></tr><tr><td align="left">(?&#x3D; re)</td><td align="left">前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td></tr><tr><td align="left">(?! re)</td><td align="left">前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td></tr><tr><td align="left">(?&gt; re)</td><td align="left">匹配的独立模式，省去回溯。</td></tr><tr><td align="left">\w</td><td align="left">匹配字母数字及下划线</td></tr><tr><td align="left">\W</td><td align="left">匹配非字母数字及下划线</td></tr><tr><td align="left">\s</td><td align="left">匹配任意空白字符，等价于 **[ \t\n\r\f]**。</td></tr><tr><td align="left">\S</td><td align="left">匹配任意非空字符</td></tr><tr><td align="left">\d</td><td align="left">匹配任意数字，等价于 [0-9].</td></tr><tr><td align="left">\D</td><td align="left">匹配任意非数字</td></tr><tr><td align="left">\A</td><td align="left">匹配字符串开始</td></tr><tr><td align="left">\Z</td><td align="left">匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td></tr><tr><td align="left">\z</td><td align="left">匹配字符串结束</td></tr><tr><td align="left">\G</td><td align="left">匹配最后匹配完成的位置。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td align="left">\B</td><td align="left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td align="left">\n, \t, 等.</td><td align="left">匹配一个换行符。匹配一个制表符。等</td></tr><tr><td align="left">\1…\9</td><td align="left">匹配第n个分组的内容。</td></tr><tr><td align="left">\10</td><td align="left">匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td></tr></tbody></table><p>举例：</p><p>在前端的代码中找出url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import requests,re</span><br><span class="line"></span><br><span class="line"># url = &quot;https://ruan0423.github.io/&quot;</span><br><span class="line">url = &#x27;https://www.baidu.com&#x27;</span><br><span class="line"></span><br><span class="line">js_tewxt = requests.get(url).text</span><br><span class="line"># print(js_tewxt)</span><br><span class="line">pattern_raw = r&quot;&quot;&quot;</span><br><span class="line">  (?:&quot;|&#x27;)                               # Start newline delimiter</span><br><span class="line">  (</span><br><span class="line">    ((?:[a-zA-Z]&#123;1,10&#125;://|//)           # Match a scheme [a-Z]*1-10 or //</span><br><span class="line">    [^&quot;&#x27;/]&#123;1,&#125;\.                        # Match a domainname (any character + dot)</span><br><span class="line">    [a-zA-Z]&#123;2,&#125;[^&quot;&#x27;]&#123;0,&#125;)              # The domainextension and/or path</span><br><span class="line">    |</span><br><span class="line">    ((?:/|\.\./|\./)                    # Start with /,../,./</span><br><span class="line">    [^&quot;&#x27;&gt;&lt;,;| *()(%%$^/\\\[\]]          # Next character can&#x27;t be...</span><br><span class="line">    [^&quot;&#x27;&gt;&lt;,;|()]&#123;1,&#125;)                   # Rest of the characters can&#x27;t be</span><br><span class="line">    |</span><br><span class="line">    ([a-zA-Z0-9_\-/]&#123;1,&#125;/               # Relative endpoint with /</span><br><span class="line">    [a-zA-Z0-9_\-/]&#123;1,&#125;                 # Resource name</span><br><span class="line">    \.(?:[a-zA-Z]&#123;1,4&#125;|action)          # Rest + extension (length 1-4 or action)</span><br><span class="line">    (?:[\?|/][^&quot;|&#x27;]&#123;0,&#125;|))              # ? mark with parameters</span><br><span class="line">    |</span><br><span class="line">    ([a-zA-Z0-9_\-]&#123;1,&#125;                 # filename</span><br><span class="line">    \.(?:php|asp|aspx|jsp|json|</span><br><span class="line">         action|html|js|txt|xml)             # . + extension</span><br><span class="line">    (?:\?[^&quot;|&#x27;]&#123;0,&#125;|))                  # ? mark with parameters</span><br><span class="line">  )</span><br><span class="line">  (?:&quot;|&#x27;)                               # End newline delimiter</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">pattern_raw = re.compile(pattern_raw,re.VERBOSE)</span><br><span class="line"></span><br><span class="line">result = pattern_raw.finditer(str(js_tewxt))</span><br><span class="line"># print(result)</span><br><span class="line"></span><br><span class="line">for i in result:</span><br><span class="line">    print(i.group())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;为什么要学re库呢？这里主要学他的正则表达，在编写安全脚本的时候肯定要遇到一些不规则的匹配规则，当然编写爬虫也少不了正则匹配</summary>
      
    
    
    
    <category term="python" scheme="https://ruan0423.github.io/categories/python/"/>
    
    
    <category term="代码 python 开发 脚本" scheme="https://ruan0423.github.io/tags/%E4%BB%A3%E7%A0%81-python-%E5%BC%80%E5%8F%91-%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用小技巧2</title>
    <link href="https://ruan0423.github.io/2023/10/28/hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://ruan0423.github.io/2023/10/28/hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2023-10-28T11:40:23.000Z</published>
    <updated>2023-10-28T12:08:57.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-在博客中加入图片"><a href="#1-在博客中加入图片" class="headerlink" title="1.在博客中加入图片"></a>1.在博客中加入图片</h2><p>使用语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 1.jpg %&#125;</span><br></pre></td></tr></table></figure><p>这样hexo会自动渲染1.jpg.，然后1.jpg的位置需要放在同文件名的文件夹中，比如这篇博客叫hexo使用小技巧，那么这张图片就要在这个目录中，如下图所示：</p><img src="/2023/10/28/hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/1.png" class=""><h2 id="2-对博客进行贴标签分类，在文件中使用"><a href="#2-对博客进行贴标签分类，在文件中使用" class="headerlink" title="2.对博客进行贴标签分类，在文件中使用"></a>2.对博客进行贴标签分类，在文件中使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">tile: 文章主题</span><br><span class="line">date: 文章日期</span><br><span class="line">categories: 文章分类</span><br><span class="line">tags: 标签</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>注意：后还要有空格，不然会编译报错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-在博客中加入图片&quot;&gt;&lt;a href=&quot;#1-在博客中加入图片&quot; class=&quot;headerlink&quot; title=&quot;1.在博客中加入图片&quot;&gt;&lt;/a&gt;1.在博客中加入图片&lt;/h2&gt;&lt;p&gt;使用语法&lt;/p&gt;
&lt;figure class=&quot;highlight plai</summary>
      
    
    
    
    <category term="说明" scheme="https://ruan0423.github.io/categories/%E8%AF%B4%E6%98%8E/"/>
    
    
    <category term="说明" scheme="https://ruan0423.github.io/tags/%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透-信息收集</title>
    <link href="https://ruan0423.github.io/2023/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://ruan0423.github.io/2023/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
    <published>2023-10-28T05:03:27.000Z</published>
    <updated>2023-10-29T07:05:42.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>对于所有的渗透而言，信息收集是最重要的一步，关系着后续的所有进程。对于内网渗透来说，信息收集主要就是对所拿下的一台主机进行信息探索。这里主要介绍一些常用的命令。</p><h1 id="二、获得主机的基本信息"><a href="#二、获得主机的基本信息" class="headerlink" title="二、获得主机的基本信息"></a>二、获得主机的基本信息</h1><p><strong>1.获取主机名hostname</strong></p><img src="/2023/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/1.png" class=""><p><strong>2.获取系统信息systeminfo</strong></p><p>**3.查看进程信息tasklist ;**这个命令可以查看当前主机运行了哪些进程。</p><h1 id="三、域信息"><a href="#三、域信息" class="headerlink" title="三、域信息"></a>三、域信息</h1><p>收集域信息是必须的，首先判断一台主机是否存在域；基本上net 命令后面执行&#x2F;domain 有域就可以执行成功；比如net time &#x2F;domain.执行成功之后就会看到主域的时间和主域的信息和主机名。</p><p>查看域控： net group  “domain controllers”</p><p><strong>1.ipconfig &#x2F;all</strong></p><p>可以看到主机的域信息和ip信息。</p><p><strong>2.net group &#x2F;domain</strong></p><p>查看域内的组信息。</p><p><strong>3.net user  &#x2F;domain</strong></p><p>查看域用户</p><p><strong>4.net group “domain admins” &#x2F;domain</strong></p><p>查看域内的管理员。</p><p>这里基本上都是使用到net  那就介绍一下net的语法吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">net user: 用于管理本地计算机上的用户帐户。您可以使用它来创建、修改、删除用户帐户，以及更改用户密码。</span><br><span class="line"></span><br><span class="line">net group: 用于管理本地计算机上的用户组。它允许您创建、修改和删除用户组，以及管理组成员。</span><br><span class="line"></span><br><span class="line">net share: 用于管理共享文件夹和打印机。您可以使用它来创建、修改和删除共享，以及查看共享的状态。</span><br><span class="line"></span><br><span class="line">net view: 用于查看网络上可用的计算机和共享资源列表。它可以帮助您查看网络中的其他计算机。</span><br><span class="line"></span><br><span class="line">net use: 用于连接到或断开网络共享资源，如文件夹或打印机。您可以使用它来映射网络驱动器，使共享资源在本地计算机上可用。</span><br><span class="line"></span><br><span class="line">net time: 用于同步计算机的时间与网络时间服务器，以确保计算机的时钟准确。</span><br><span class="line"></span><br><span class="line">net start 和 net stop: 用于启动或停止 Windows 服务。您可以使用这些命令来管理系统中正在运行的服务。</span><br><span class="line"></span><br><span class="line">netstat: 用于查看网络连接和统计信息，包括本地和远程计算机之间的网络连接。</span><br></pre></td></tr></table></figure><h1 id="四、用户信息"><a href="#四、用户信息" class="headerlink" title="四、用户信息"></a>四、用户信息</h1><p>域信息收集之后再查看一下当前主机的信息。通常查看当前主机有些什么特权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.whoami /all</span><br><span class="line">可以一键查看当前用户的信息和特权</span><br><span class="line"></span><br><span class="line">2.whoami /priv 只查看特权</span><br><span class="line"></span><br><span class="line">3.quser 查看在线的用户</span><br></pre></td></tr></table></figure><h1 id="五、网络信息"><a href="#五、网络信息" class="headerlink" title="五、网络信息"></a>五、网络信息</h1><p><strong>1.arp -a</strong></p><p>可查看网卡信息</p><p><strong>2.netstat -a</strong></p><p>监听的端口</p><p>3.探测出网情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -c &quot;1..65535 | % &#123;echo ((new-object Net.Sockets.TcpClient).Connect(&#x27;allports.exposed&#x27;,$_)) $_ &#125; 2&gt;$null&quot;</span><br></pre></td></tr></table></figure><h1 id="六、防火墙"><a href="#六、防火墙" class="headerlink" title="六、防火墙"></a>六、防火墙</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看防火墙状态 netsh advfirewall show allprofiles</span><br><span class="line">防火墙日志目录 netsh firewall show logging</span><br><span class="line">防火墙规则 netsh advfirewall firewall show rule name=all</span><br><span class="line">netsh firewall show config</span><br><span class="line">netsh firewall show state</span><br></pre></td></tr></table></figure><h1 id="七、密码信息，票据信息"><a href="#七、密码信息，票据信息" class="headerlink" title="七、密码信息，票据信息"></a>七、密码信息，票据信息</h1><p>密码信息，有的密码是保存在浏览器的填充中。</p><p>票据信息可以使用cmdkey &#x2F;l</p><p>klist</p><p>文章主要参考：<a href="https://websec.readthedocs.io/zh/latest/intranet/windows/info.html#section-5">https://websec.readthedocs.io/zh/latest/intranet/windows/info.html#section-5</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;对于所有的渗透而言，信息收集是最重要的一步，关系着后续的所有进程。对于内网渗透来说，信息收集主要就是对所拿下的一台主机进行信</summary>
      
    
    
    
    <category term="内网渗透" scheme="https://ruan0423.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="内网渗透" scheme="https://ruan0423.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
</feed>
