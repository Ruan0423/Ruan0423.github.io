{"meta":{"title":"Ruan❥(^_-) Blog","subtitle":"","description":"","author":"Traveler","url":"https://Ruan0423.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2023-10-28T10:13:57.734Z","updated":"2023-10-28T10:13:57.734Z","comments":true,"path":"links/index.html","permalink":"https://ruan0423.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-10-28T10:13:57.734Z","updated":"2023-10-28T10:13:57.734Z","comments":false,"path":"categories/index.html","permalink":"https://ruan0423.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-10-28T10:13:57.734Z","updated":"2023-10-28T10:13:57.734Z","comments":false,"path":"books/index.html","permalink":"https://ruan0423.github.io/books/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2023-10-28T10:13:57.732Z","updated":"2023-10-28T10:13:57.732Z","comments":false,"path":"/404.html","permalink":"https://ruan0423.github.io/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-10-28T10:13:57.736Z","updated":"2023-10-28T10:13:57.736Z","comments":false,"path":"repository/index.html","permalink":"https://ruan0423.github.io/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-10-28T10:13:57.733Z","updated":"2023-10-28T10:13:57.733Z","comments":false,"path":"about/index.html","permalink":"https://ruan0423.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2023-10-28T10:13:57.736Z","updated":"2023-10-28T10:13:57.736Z","comments":false,"path":"tags/index.html","permalink":"https://ruan0423.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python之re库，正则表达","slug":"python之re库，正则表达","date":"2023-10-29T09:02:41.000Z","updated":"2023-10-29T14:22:46.514Z","comments":true,"path":"2023/10/29/python之re库，正则表达/","link":"","permalink":"https://ruan0423.github.io/2023/10/29/python%E4%B9%8Bre%E5%BA%93%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/","excerpt":"","text":"一、前言为什么要学re库呢？这里主要学他的正则表达，在编写安全脚本的时候肯定要遇到一些不规则的匹配规则，当然编写爬虫也少不了正则匹配去找到一些具有特殊特征的字符串。因此这是十分必要的，然而。re库使 Python 语言拥有全部的正则表达式功能。我会先介绍一些常见的函数的功能并且举例。后再举例说明。一些常见的情况。当然除了掌握函数的功能，这只是基础，重点是自己会构造pattern。 这里介绍的匹配通俗来讲就是在一段字符串里面找某段字符串（pattern），在re库里面就有re.match()和re.search()等一些函数来找。 一定要会使用编译函数comlie(),find_all(),还有会正则表达格式。 二、re.match()re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 none。 12规则是re.match(pattern,string,flag) 举例说明： 12345678910import reprint(re.match(&#x27;www&#x27;,&#x27;www.baidu.com&#x27;))print(re.match(&#x27;www&#x27;,&#x27;www.baidu.com&#x27;).span())print(re.match(&#x27;www&#x27;,&#x27;ewwww&#x27;))#输出&lt;re.Match object; span=(0, 3), match=&#x27;www&#x27;&gt; #匹配成功返回一个对象（0,3） #只要起始位置到结束None #起始位置不匹配。返回空 这里就要提到另外一个知识点，我们知道，re.match返回的是一个obj，其中里面包含了span也就是位置，那我要返回匹配到的字符呢？为什么要返回匹配到的字符呢？因为这里的pattern到后面我们是自己设置的一些模式化的字符，比如我们要在一个js文件里面找出url，那么我们就要编写pattern模式，然后返回这个匹配到的模式字符。 所有这里引出来group() group() 当使用正则表达式匹配时，通常会定义一个模式，该模式中包含一个或多个用括号括起来的子表达式，这些子表达式被称为”捕获组”。这些捕获组用于从匹配的文本中提取特定部分。例如，考虑以下示例： 12345678910111213141516171819202122232425262728import retext = &quot;My phone number is 123-456-7890.&quot;# 匹配电话号码的模式，使用捕获组提取区号、中间号和最后四位数字pattern = r&#x27;(\\d&#123;3&#125;)-(\\d&#123;3&#125;)-(\\d&#123;4&#125;)&#x27;match = re.search(pattern, text)if match: full_match = match.group(0) # 整个匹配 area_code = match.group(1) # 第一个捕获组 middle_digits = match.group(2) # 第二个捕获组 last_digits = match.group(3) # 第三个捕获组 print(&quot;Full Match: &quot;, full_match) print(&quot;Area Code: &quot;, area_code) print(&quot;Middle Digits: &quot;, middle_digits) print(&quot;Last Digits: &quot;, last_digits)else: print(&quot;No match.&quot;)#结果Full Match: 123-456-7890Area Code: 123Middle Digits: 456Last Digits: 7890 通俗解释就是：在pattern = r&#39;(\\d&#123;3&#125;)-(\\d&#123;3&#125;)-(\\d&#123;4&#125;)&#39;模式中，有三个捕获组，当匹配到的时候就可以使用group（）返回整个匹配到的内容。使用group（1）就可以返回第一个捕获组。 如果要不区分大小写，就把flag设置为 re.M|re.I 例如 1re.search(pattern, text，re.M|re.I) 三、re.search()OK！到这里基本上已经了解到什么是匹配什么是模式，怎么返回匹配到的内容或者位置。现在引入另外一个常见的就是search 通常我们使用的都是这个去匹配而不是使用match； 12345678910111213141516171819使用规则re.search(pattern,string,flag)与match的区别在于，search是从整个string中查找到pattern，然后返回obj,否则返回none。而match是只从开始找，如果一开始就不匹配那就返回noneimport repattern = &#x27;ww&#x27;string = &#x27;aww&#x27;string2 = &#x27;wwsdgsdww&#x27;match = re.search(pattern,string)match2 = re.search(pattern,string2)print(match)print(match2)print(match.group())#输出&lt;re.Match object; span=(1, 3), match=&#x27;ww&#x27;&gt;&lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt;ww 四、替换函数re.sub（） 12345678re.sub(pattern, repl, string, count=0, flags=0)参数：- pattern : 正则中的模式字符串。- repl : 替换的字符串，也可为一个函数。- string : 要被查找替换的原始字符串。- count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 举例： 12345678910import repattern = &#x27;ww&#x27;string2 = &#x27;wwsdgsdww&#x27;replace = re.sub(pattern,&quot;okok&quot;,string2)print(replace)#结果okoksdgsdokok 五、编译函数compile()主要作用就是编译，什么意思？就是将pattern进行编译，在不编译pattern之前，我们是直接把pattern放进函数里面的，那样他会自己编译，但是当我们编译了之后就不用直接调用了。 举例： 12345678910111213141516 import re pattern = &#x27;ww&#x27; string2 = &#x27;wwsdgsdww&#x27; replace = re.search(pattern,string2) print(replace) #使用编译 pattern = re.compile(pattern) replace = pattern.search(string2) print(replace) #输出 &lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt;&lt;re.Match object; span=(0, 2), match=&#x27;ww&#x27;&gt; 六、查找函数find_all()，finditer()与search的区别在于它找到的是多个，返回的是一个列表。 规则： 1234findall(string[, pos[, endpos]])比如：findall(string,0,10) 举例 1234567891011import repattern = &#x27;ww&#x27;string2 = &#x27;wwsdgsdww&#x27;pattern = re.compile(pattern)result = pattern.findall(string2)print(result)#输出[&#x27;ww&#x27;, &#x27;ww&#x27;] finditer和find_all一样。只不过finditer返回的是迭代，而不是列表。需要使用for循环print出来。 七、正则表达式这里很重要，但是知识点又很多，所以看懂就行，建议当要设置匹配某个字符的特征表达式的时候，集合chatgpt来写。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。 re{ n,} 匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) 对正则表达式分组并记住匹配的文本 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?&#x3D; re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配字母数字及下划线 \\W 匹配非字母数字及下划线 \\s 匹配任意空白字符，等价于 **[ \\t\\n\\r\\f]**。 \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]. \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 举例： 在前端的代码中找出url： 1234567891011121314151617181920212223242526272829303132333435363738import requests,re# url = &quot;https://ruan0423.github.io/&quot;url = &#x27;https://www.baidu.com&#x27;js_tewxt = requests.get(url).text# print(js_tewxt)pattern_raw = r&quot;&quot;&quot; (?:&quot;|&#x27;) # Start newline delimiter ( ((?:[a-zA-Z]&#123;1,10&#125;://|//) # Match a scheme [a-Z]*1-10 or // [^&quot;&#x27;/]&#123;1,&#125;\\. # Match a domainname (any character + dot) [a-zA-Z]&#123;2,&#125;[^&quot;&#x27;]&#123;0,&#125;) # The domainextension and/or path | ((?:/|\\.\\./|\\./) # Start with /,../,./ [^&quot;&#x27;&gt;&lt;,;| *()(%%$^/\\\\\\[\\]] # Next character can&#x27;t be... [^&quot;&#x27;&gt;&lt;,;|()]&#123;1,&#125;) # Rest of the characters can&#x27;t be | ([a-zA-Z0-9_\\-/]&#123;1,&#125;/ # Relative endpoint with / [a-zA-Z0-9_\\-/]&#123;1,&#125; # Resource name \\.(?:[a-zA-Z]&#123;1,4&#125;|action) # Rest + extension (length 1-4 or action) (?:[\\?|/][^&quot;|&#x27;]&#123;0,&#125;|)) # ? mark with parameters | ([a-zA-Z0-9_\\-]&#123;1,&#125; # filename \\.(?:php|asp|aspx|jsp|json| action|html|js|txt|xml) # . + extension (?:\\?[^&quot;|&#x27;]&#123;0,&#125;|)) # ? mark with parameters ) (?:&quot;|&#x27;) # End newline delimiter&quot;&quot;&quot;pattern_raw = re.compile(pattern_raw,re.VERBOSE)result = pattern_raw.finditer(str(js_tewxt))# print(result)for i in result: print(i.group()) #结果 1&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&#x27;","categories":[{"name":"python","slug":"python","permalink":"https://ruan0423.github.io/categories/python/"}],"tags":[{"name":"代码 python 开发 脚本","slug":"代码-python-开发-脚本","permalink":"https://ruan0423.github.io/tags/%E4%BB%A3%E7%A0%81-python-%E5%BC%80%E5%8F%91-%E8%84%9A%E6%9C%AC/"}]},{"title":"hexo使用小技巧2","slug":"hexo使用小技巧","date":"2023-10-28T11:40:23.000Z","updated":"2023-10-28T12:08:57.825Z","comments":true,"path":"2023/10/28/hexo使用小技巧/","link":"","permalink":"https://ruan0423.github.io/2023/10/28/hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"1.在博客中加入图片使用语法 1&#123;% asset_img 1.jpg %&#125; 这样hexo会自动渲染1.jpg.，然后1.jpg的位置需要放在同文件名的文件夹中，比如这篇博客叫hexo使用小技巧，那么这张图片就要在这个目录中，如下图所示： 2.对博客进行贴标签分类，在文件中使用123456---tile: 文章主题date: 文章日期categories: 文章分类tags: 标签--- 注意：后还要有空格，不然会编译报错。","categories":[{"name":"说明","slug":"说明","permalink":"https://ruan0423.github.io/categories/%E8%AF%B4%E6%98%8E/"}],"tags":[{"name":"说明","slug":"说明","permalink":"https://ruan0423.github.io/tags/%E8%AF%B4%E6%98%8E/"}]},{"title":"内网渗透-信息收集","slug":"内网渗透-信息收集","date":"2023-10-28T05:03:27.000Z","updated":"2023-10-29T07:05:42.235Z","comments":true,"path":"2023/10/28/内网渗透-信息收集/","link":"","permalink":"https://ruan0423.github.io/2023/10/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"","text":"一、前言对于所有的渗透而言，信息收集是最重要的一步，关系着后续的所有进程。对于内网渗透来说，信息收集主要就是对所拿下的一台主机进行信息探索。这里主要介绍一些常用的命令。 二、获得主机的基本信息1.获取主机名hostname 2.获取系统信息systeminfo **3.查看进程信息tasklist ;**这个命令可以查看当前主机运行了哪些进程。 三、域信息收集域信息是必须的，首先判断一台主机是否存在域；基本上net 命令后面执行&#x2F;domain 有域就可以执行成功；比如net time &#x2F;domain.执行成功之后就会看到主域的时间和主域的信息和主机名。 查看域控： net group “domain controllers” 1.ipconfig &#x2F;all 可以看到主机的域信息和ip信息。 2.net group &#x2F;domain 查看域内的组信息。 3.net user &#x2F;domain 查看域用户 4.net group “domain admins” &#x2F;domain 查看域内的管理员。 这里基本上都是使用到net 那就介绍一下net的语法吧 123456789101112131415net user: 用于管理本地计算机上的用户帐户。您可以使用它来创建、修改、删除用户帐户，以及更改用户密码。net group: 用于管理本地计算机上的用户组。它允许您创建、修改和删除用户组，以及管理组成员。net share: 用于管理共享文件夹和打印机。您可以使用它来创建、修改和删除共享，以及查看共享的状态。net view: 用于查看网络上可用的计算机和共享资源列表。它可以帮助您查看网络中的其他计算机。net use: 用于连接到或断开网络共享资源，如文件夹或打印机。您可以使用它来映射网络驱动器，使共享资源在本地计算机上可用。net time: 用于同步计算机的时间与网络时间服务器，以确保计算机的时钟准确。net start 和 net stop: 用于启动或停止 Windows 服务。您可以使用这些命令来管理系统中正在运行的服务。netstat: 用于查看网络连接和统计信息，包括本地和远程计算机之间的网络连接。 四、用户信息域信息收集之后再查看一下当前主机的信息。通常查看当前主机有些什么特权 1234561.whoami /all可以一键查看当前用户的信息和特权2.whoami /priv 只查看特权3.quser 查看在线的用户 五、网络信息1.arp -a 可查看网卡信息 2.netstat -a 监听的端口 3.探测出网情况 1powershell -c &quot;1..65535 | % &#123;echo ((new-object Net.Sockets.TcpClient).Connect(&#x27;allports.exposed&#x27;,$_)) $_ &#125; 2&gt;$null&quot; 六、防火墙12345查看防火墙状态 netsh advfirewall show allprofiles防火墙日志目录 netsh firewall show logging防火墙规则 netsh advfirewall firewall show rule name=allnetsh firewall show confignetsh firewall show state 七、密码信息，票据信息密码信息，有的密码是保存在浏览器的填充中。 票据信息可以使用cmdkey &#x2F;l klist 文章主要参考：https://websec.readthedocs.io/zh/latest/intranet/windows/info.html#section-5","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://ruan0423.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://ruan0423.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://ruan0423.github.io/categories/python/"},{"name":"说明","slug":"说明","permalink":"https://ruan0423.github.io/categories/%E8%AF%B4%E6%98%8E/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://ruan0423.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"代码 python 开发 脚本","slug":"代码-python-开发-脚本","permalink":"https://ruan0423.github.io/tags/%E4%BB%A3%E7%A0%81-python-%E5%BC%80%E5%8F%91-%E8%84%9A%E6%9C%AC/"},{"name":"说明","slug":"说明","permalink":"https://ruan0423.github.io/tags/%E8%AF%B4%E6%98%8E/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://ruan0423.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]}